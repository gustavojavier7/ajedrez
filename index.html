<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Analizador de ajedrez interactivo con soporte para Stockfish y logs adaptativos.">
    <meta name="keywords" content="ajedrez, analizador, Stockfish, JavaScript">
    <title>Analizador de Ajedrez con Logs Adaptativos</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" async>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script>
        // Fallback para chess.js en caso de que el CDN falle
        window.Chess || document.write('<script src="local/chess.min.js"><\/script>');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f8f9fa;
            min-height: 100vh;
            line-height: 1.4;
            color: #212529;
            font-size: 14px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 8px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 16px;
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 600;
            color: #343a40;
            margin-bottom: 4px;
        }

        .input-section {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .input-row {
            display: flex;
            gap: 12px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .input-group {
            flex: 1;
            min-width: 300px;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            color: #495057;
            font-size: 0.875rem;
            margin-bottom: 4px;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.875rem;
            transition: border-color 0.15s ease-in-out;
            background-color: #fff;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #80bdff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid transparent;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
            font-size: 0.875rem;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            text-decoration: none;
        }

        .btn:disabled {
            opacity: 0.65;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: #007bff;
            border-color: #007bff;
            color: #fff;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #0056b3;
            border-color: #004085;
        }

        .btn-success {
            background-color: #28a745;
            border-color: #28a745;
            color: #fff;
        }

        .btn-success:hover:not(:disabled) {
            background-color: #1e7e34;
            border-color: #1c7430;
        }

        .btn-warning {
            background-color: #ffc107;
            border-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover:not(:disabled) {
            background-color: #e0a800;
            border-color: #d39e00;
        }

        .btn-danger {
            background-color: #dc3545;
            border-color: #dc3545;
            color: #fff;
        }

        .btn-danger:hover:not(:disabled) {
            background-color: #c82333;
            border-color: #bd2130;
        }

        .btn-secondary {
            background-color: #6c757d;
            border-color: #6c757d;
            color: #fff;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #5a6268;
            border-color: #545b62;
        }

        .main-layout {
            display: flex;
            gap: 12px;
            flex: 1;
            min-height: 0;
        }

        .board-container-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 560px;
            min-width: 560px;
            flex-shrink: 0;
        }

        .board-section {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 8px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
        }

        .game-status-compact {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.875rem;
        }

        .game-status-compact.status-info {
            background-color: #d1ecf1;
            border-color: #bee5eb;
            color: #0c5460;
        }

        .game-status-compact.status-success {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .game-status-compact.status-warning {
            background-color: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }

        .game-status-compact.status-danger {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .pv-section-main {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            margin-top: 8px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 536px;
            overflow: hidden;
        }

        .pv-section-main .pv-title {
            font-size: 0.875rem;
            color: #495057;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
        }

        .pv-line-main {
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            color: #000;
            line-height: 1.5;
            word-wrap: break-word;
            max-height: 120px;
            overflow-y: auto;
            background: white;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            white-space: pre-wrap;
        }

        .right-panel {
            width: 450px;
            min-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .analysis-panel {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 16px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .analysis-section {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e9ecef;
        }

        .analysis-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .section-title {
            font-weight: 600;
            color: #495057;
            font-size: 0.875rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .engine-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .engine-controls .btn {
            flex: 1;
            min-width: 120px;
        }

        .engine-status {
            font-size: 0.8125rem;
            color: #6c757d;
            margin-bottom: 8px;
            padding: 6px 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #007bff;
        }

        .evaluation-display {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .evaluation {
            font-weight: 600;
            font-size: 1.125rem;
            padding: 4px 8px;
            border-radius: 4px;
            min-width: 80px;
            text-align: center;
            border: 1px solid #dee2e6;
        }

        .eval-positive {
            color: #155724;
            background-color: #d4edda;
            border-color: #c3e6cb;
        }

        .eval-negative {
            color: #721c24;
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }

        .eval-neutral {
            color: #495057;
            background-color: #e9ecef;
            border-color: #ced4da;
        }

        .best-move {
            font-weight: 500;
            color: #007bff;
            font-size: 0.875rem;
            flex: 1;
        }

        .stats-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #6c757d;
            margin-bottom: 8px;
            gap: 8px;
        }

        .stats-display > span {
            flex: 1;
            text-align: center;
            padding: 4px 6px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        .logs-section {
            background: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            width: 100%;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }

        .logs-title {
            color: #000;
            font-size: 0.875rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .logs-controls {
            display: flex;
            gap: 6px;
        }

        .logs-controls button {
            background: #f8f9fa;
            border: 1px solid #ced4da;
            color: #000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s ease-in-out;
        }

        .logs-controls button:hover {
            background: #e2e6ea;
        }

        .logs-container {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
            height: 180px;
            overflow-y: auto;
            background: #ffffff;
            color: #000000;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }

        .log-entry {
            display: flex;
            margin-bottom: 4px;
            padding: 2px 4px;
            border-radius: 2px;
            animation: fadeIn 0.3s ease-in-out;
        }

        .log-entry.info {
            color: #000;
            background-color: rgba(88, 166, 255, 0.1);
        }

        .log-entry.success {
            color: #000;
            background-color: rgba(63, 185, 80, 0.1);
        }

        .log-entry.warning {
            color: #000;
            background-color: rgba(248, 81, 73, 0.1);
        }

        .log-entry.adaptation {
            color: #000;
            background-color: rgba(240, 136, 62, 0.1);
        }

        .log-timestamp {
            color: #6c757d;
            margin-right: 8px;
            min-width: 60px;
        }

        .log-message {
            flex: 1;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .moves-panel {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 16px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            flex: 1;
            min-height: 0;
        }

        .moves-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e9ecef;
        }

        .moves-header h3 {
            font-size: 0.875rem;
            font-weight: 600;
            color: #495057;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1rem;
            color: #6c757d;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
        }

        .close-btn:hover {
            color: #495057;
            background-color: #f8f9fa;
        }

        .moves-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .move-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin: 1px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
            border: 1px solid transparent;
        }

        .move-item:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
        }

        .move-notation {
            font-weight: 500;
            color: #495057;
            font-size: 0.875rem;
            font-family: 'Courier New', monospace;
        }

        .move-coords {
            font-size: 0.75rem;
            color: #6c757d;
            font-family: 'Courier New', monospace;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .loading i {
            font-size: 2.5rem;
            margin-bottom: 16px;
            color: #007bff;
        }

        .logs-container::-webkit-scrollbar,
        .pv-line-main::-webkit-scrollbar {
            width: 6px;
        }

        .logs-container::-webkit-scrollbar-track,
        .pv-line-main::-webkit-scrollbar-track {
            background: #e9ecef;
        }

        .logs-container::-webkit-scrollbar-thumb,
        .pv-line-main::-webkit-scrollbar-thumb {
            background: #ced4da;
            border-radius: 3px;
        }

        .logs-container::-webkit-scrollbar-thumb:hover,
        .pv-line-main::-webkit-scrollbar-thumb:hover {
            background: #adb5bd;
        }

        .square-highlight {
            animation: blink-light 0.2s ease-in-out 8;
        }

        .square-highlight.dark {
            animation: blink-dark 0.2s ease-in-out 8;
        }

        @keyframes blink-light {
            0%, 50% { fill: #cce5ff; }
            50.1%, 100% { fill: #F5F5DC; }
        }

        @keyframes blink-dark {
            0%, 50% { fill: #99ccff; }
            50.1%, 100% { fill: #C19A6B; }
        }

        .adaptive-config {
            margin-top: 8px;
        }

        .adaptive-config label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            transition: opacity 0.2s ease-in-out;
        }

        .adaptive-config label.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .adaptive-config input[type="checkbox"]:disabled {
            cursor: not-allowed;
        }

        @media (max-width: 1200px) {
            .main-layout {
                flex-direction: column;
            }

            .board-container-wrapper {
                align-self: center;
                width: 560px;
                min-width: 560px;
            }

            .right-panel {
                width: 100%;
                min-width: unset;
            }

            .analysis-panel {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 16px;
            }

            .analysis-section {
                border-bottom: none;
                padding-bottom: 0;
                margin-bottom: 0;
            }

            .logs-section {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 12px;
            }

            .board-container-wrapper {
                width: 100% !important;
                min-width: unset !important;
                max-width: 560px;
                align-self: center;
            }

            .pv-section-main {
                max-width: 100%;
            }

            .input-row {
                flex-direction: column;
            }

            .input-group {
                min-width: unset;
            }

            .button-group {
                flex-direction: column;
            }

            .analysis-panel {
                grid-template-columns: 1fr;
            }

            .engine-controls {
                flex-direction: column;
            }

            .engine-controls .btn {
                min-width: unset;
            }

            .right-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-layout">
            <div class="board-container-wrapper">
                <div class="board-section">
                    <div id="chessboard">
                        <div class="loading">
                            <i class="fas fa-chess-board"></i>
                            <p>Cargando tablero...</p>
                        </div>
                    </div>
                </div>
                
                <div id="gameStatus" class="game-status-compact">
                    <i class="fas fa-info-circle"></i>
                    <span>Cargando...</span>
                </div>

                <div class="pv-section-main">
                    <div class="pv-title">
                        <i class="fas fa-route"></i>
                        Mejor línea de juego:
                    </div>
                    <div id="pvLine" class="pv-line-main">Inicia el análisis para ver la mejor línea</div>
                </div>
            </div>

            <div class="right-panel">
                <div class="input-section">
                    <div class="input-row">
                        <div class="input-group">
                            <label for="fenInput">
                                <i class="fas fa-code"></i> Posición FEN:
                            </label>
                            <input type="text"
                                   id="fenInput"
                                   value="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
                                   placeholder="Ingresa la posición FEN"
                                   onclick="this.select()">
                        </div>
                        <div class="input-group" style="max-width: 200px;">
                            <label for="modeSelect">
                                <i class="fas fa-gamepad"></i> Modo:
                            </label>
                            <select id="modeSelect">
                                <option value="edit">Edición y análisis</option>
                                <option value="human">Humano vs Humano</option>
                                <option value="cpu">Versus CPU</option>
                            </select>
                        </div>
                        <div class="button-group">
                            <button onclick="drawBoard()" class="btn btn-primary">
                                <i class="fas fa-chess-board"></i> Cargar Posición
                            </button>
                            <button onclick="showLegalMoves()" id="showMovesBtn" class="btn btn-success">
                                <i class="fas fa-list"></i> Movimientos
                            </button>
                        </div>
                    </div>
                </div>

                <div class="logs-section">
                    <div class="logs-header">
                        <div class="logs-title">
                            <i class="fas fa-terminal"></i>
                            Logs de Adaptación
                        </div>
                        <div class="logs-controls">
                            <button onclick="clearLogs()" title="Limpiar logs">
                                <i class="fas fa-trash"></i>
                            </button>
                            <button onclick="toggleLogsPause()" id="pauseLogsBtn" title="Pausar logs">
                                <i class="fas fa-pause"></i>
                            </button>
                        </div>
                    </div>
                    <div class="logs-container" id="logsContainer"></div>
                </div>

                <div class="analysis-panel">
                    <div class="analysis-section">
                        <div class="section-title">
                            <i class="fas fa-microchip"></i>
                            Motor de Análisis
                        </div>
                        <div class="engine-controls">
                            <button onclick="toggleEngine()" id="engineToggleBtn" class="btn btn-secondary">
                                <i class="fas fa-plug"></i> Conectar Motor
                            </button>
                            <button onclick="toggleAnalysis()" id="analysisToggleBtn" class="btn btn-success">
                                <i class="fas fa-play"></i> Analizar
                            </button>
                            <button onclick="forceBestMove()" id="forceMoveBtn" class="btn btn-warning" style="display: none;">
                                <i class="fas fa-forward"></i> Forzar
                            </button>
                        </div>
                        <div id="engineStatus" class="engine-status">Motor no conectado</div>
                        
                        <div class="adaptive-config">
                            <label id="adaptiveLabel">
                                <input type="checkbox" id="adaptiveToggle" checked>
                                <span>Modo adaptativo</span>
                            </label>
                        </div>
                    </div>

                    <div class="analysis-section">
                        <div class="section-title">
                            <i class="fas fa-balance-scale"></i>
                            Evaluación
                        </div>
                        <div class="evaluation-display">
                            <span id="evaluation" class="evaluation">--</span>
                            <span id="bestMove" class="best-move">--</span>
                        </div>
                        <div class="stats-display">
                            <span id="engineStats">--</span>
                            <span id="memoryStats">--</span>
                        </div>
                    </div>
                </div>

                <div id="legalMoves" class="moves-panel" style="display: none;">
                    <div class="moves-header">
                        <h3 id="legalMovesHeader">
                            <i class="fas fa-chess-knight"></i>
                            Movimientos Legales
                        </h3>
                        <button onclick="hideLegalMoves()" class="close-btn">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div id="legalMovesList" class="moves-list"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===================== VARIABLES GLOBALES =====================
        const pieceSymbols = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        const squareSize = 65;
        const boardSize = 8 * squareSize;
        let board = Array(8).fill().map(() => Array(8).fill(null));
        let chess = null;
        let lastMove = null;
        let stockfish = null;
        let blobURL = null;
        let isEngineConnected = false;
        let isAnalyzing = false;
        let gameMode = 'edit';
        let playerColor = 'white';
        let selectedSquare = null;
        let possibleMoves = [];
        
        let logs = [];
        let logsPaused = false;
        const MAX_LOGS = 8;
        
        let previousHighlightedSquares = [];
        let pvObserver = null;
        
        let lastStats = {
            nps: 0,
            pv: '',
            pvs: {},
            evaluation: null,
            depth: 0,
            bestMove: '',
            bestMoveSan: '',
            nodes: 0,
            time: 0
        };

        let currentPVAnalysis = {
    pvCount: 10,                    // Cambiado de 3 a 10 - analizar más variantes
    depth: 1,                       // Cambiado de 6 a 1 - empezar con análisis superficial
    targetEvaluation: 0,            // Siempre buscar equilibrio perfecto
    searchInProgress: false,        // Estado de la búsqueda actual
    adaptationActive: false,        // Estado del modo adaptativo
    
    // Nuevos campos para mejor control del proceso
    iterationCount: 0,              // Contador de iteraciones del análisis
    lastIterationTime: null,        // Timestamp de la última iteración
    bestResultSoFar: null,          // Mejor equilibrio encontrado hasta ahora
    convergenceHistory: []          // Historial de convergencia hacia equilibrio
};

        // ===================== SISTEMA DE LOGS =====================
        function addLog(type, message) {
            if (logsPaused) return;
            
            const timestamp = new Date().toLocaleTimeString('es-ES', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            const logEntry = {
                id: Date.now(),
                timestamp: timestamp,
                type: type,
                message: message
            };
            
            logs.unshift(logEntry);
            
            if (logs.length > MAX_LOGS) {
                logs = logs.slice(0, MAX_LOGS);
            }
            
            updateLogsDisplay();
        }
        
        function updateLogsDisplay() {
            const container = document.getElementById('logsContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            logs.forEach(log => {
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry ${log.type}`;
                
                logDiv.innerHTML = `
                    <span class="log-timestamp">${log.timestamp}</span>
                    <span class="log-message">${log.message}</span>
                `;
                
                container.appendChild(logDiv);
            });
            
            if (!logsPaused) {
                container.scrollTop = 0;
            }
        }
        
        function clearLogs() {
            logs = [];
            updateLogsDisplay();
            addLog('info', 'Logs limpiados');
        }
        
        function toggleLogsPause() {
            logsPaused = !logsPaused;
            const btn = document.getElementById('pauseLogsBtn');
            
            if (logsPaused) {
                btn.innerHTML = '<i class="fas fa-play"></i>';
                btn.title = 'Reanudar logs';
                addLog('info', 'Logs pausados');
            } else {
                btn.innerHTML = '<i class="fas fa-pause"></i>';
                btn.title = 'Pausar logs';
                addLog('info', 'Logs reanudados');
            }
        }

        // ===================== SISTEMA DE REPORTE ADAPTATIVO =====================
        function reportAdaptiveModeStatus() {
            const adaptiveToggle = document.getElementById('adaptiveToggle');
            const adaptiveEnabled = adaptiveToggle ? adaptiveToggle.checked : true;
            
            switch (gameMode) {
                case 'edit':
                    if (adaptiveEnabled) {
                        addLog('info', `Modo: Edición y análisis | Adaptativo: ACTIVADO (disponible para análisis manual)`);
                    } else {
                        addLog('info', `Modo: Edición y análisis | Adaptativo: DESACTIVADO (análisis objetivo estándar)`);
                    }
                    break;
                    
                case 'human':
                    addLog('info', `Modo: Humano vs Humano | Adaptativo: NO APLICABLE (análisis objetivo para ambos jugadores)`);
                    break;
                    
                case 'cpu':
                    if (adaptiveEnabled) {
                        addLog('info', `Modo: Versus CPU | Adaptativo: ACTIVADO (la CPU ajustará su fuerza dinámicamente)`);
                    } else {
                        addLog('info', `Modo: Versus CPU | Adaptativo: DESACTIVADO (la CPU jugará con máxima fuerza)`);
                    }
                    break;
            }
        }

        // ===================== GESTIÓN DE CONTROLES ADAPTATIVOS =====================
        function updateAdaptiveControlState() {
            const adaptiveToggle = document.getElementById('adaptiveToggle');
            const adaptiveLabel = document.getElementById('adaptiveLabel');
            
            if (gameMode === 'human') {
                adaptiveToggle.disabled = true;
                adaptiveLabel.classList.add('disabled');
                adaptiveLabel.title = 'El modo adaptativo no se aplica en partidas humano vs humano';
            } else {
                adaptiveToggle.disabled = false;
                adaptiveLabel.classList.remove('disabled');
                adaptiveLabel.title = '';
            }
        }

        // ===================== FUNCIONES PRINCIPALES DE INTERFAZ =====================
        function updateButtonStates() {
            const engineToggleBtn = document.getElementById('engineToggleBtn');
            const analysisToggleBtn = document.getElementById('analysisToggleBtn');
            const showMovesBtn = document.getElementById('showMovesBtn');
            const forceMoveBtn = document.getElementById('forceMoveBtn');

            if (isEngineConnected) {
                engineToggleBtn.innerHTML = '<i class="fas fa-power-off"></i> Desconectar';
                engineToggleBtn.className = 'btn btn-warning';
            } else {
                engineToggleBtn.innerHTML = '<i class="fas fa-plug"></i> Conectar Motor';
                engineToggleBtn.className = 'btn btn-secondary';
            }

            if (isAnalyzing) {
                analysisToggleBtn.innerHTML = '<i class="fas fa-stop"></i> Detener';
                analysisToggleBtn.className = 'btn btn-danger';
                analysisToggleBtn.disabled = false;
            } else {
                analysisToggleBtn.innerHTML = '<i class="fas fa-play"></i> Analizar';
                analysisToggleBtn.className = 'btn btn-success';
                analysisToggleBtn.disabled = !isEngineConnected || chess?.game_over();
            }

            if (showMovesBtn) {
                showMovesBtn.disabled = chess?.game_over();
            }

            if (forceMoveBtn) {
                const cpuTurn = gameMode === 'cpu' && chess && chess.turn() !== (playerColor === 'white' ? 'w' : 'b');
                const shouldShow = gameMode === 'cpu' && (isAnalyzing || cpuTurn);
                forceMoveBtn.style.display = shouldShow ? 'inline-flex' : 'none';
                forceMoveBtn.disabled = !isAnalyzing && !lastStats.bestMoveSan;
            }

            updateAdaptiveControlState();
        }

        function parseFEN(fen) {
            const [position] = fen.split(' ');
            const rows = position.split('/');
            board = Array(8).fill().map(() => Array(8).fill(null));

            for (let row = 0; row < 8; row++) {
                let col = 0;
                const actualRow = 7 - row;
                for (let char of rows[row]) {
                    if (/\d/.test(char)) {
                        col += parseInt(char);
                    } else {
                        board[actualRow][col] = char;
                        col++;
                    }
                }
            }
        }

        function uciToSan(uciMove) {
            if (!uciMove || uciMove.length < 4) return uciMove;
            
            const from = uciMove.substring(0, 2);
            const to = uciMove.substring(2, 4);
            const promotion = uciMove.length > 4 ? uciMove[4] : undefined;
            
            const tempChess = new Chess(chess.fen());
            
            try {
                const move = tempChess.move({
                    from: from,
                    to: to,
                    promotion: promotion
                });
                return move ? move.san : uciMove;
            } catch (e) {
                return uciMove;
            }
        }

        function formatEvaluation(score, isMate) {
            if (isMate) {
                return score > 0 ? `+M${score}` : `-M${Math.abs(score)}`;
            }
            
            const pawns = score / 100;
            return pawns > 0 ? `+${pawns.toFixed(2)}` : pawns.toFixed(2);
        }

        function generateChessboardSVG() {
            let svg = `<svg width="${boardSize + 40}" height="${boardSize + 40}" xmlns="http://www.w3.org/2000/svg">`;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const x = col * squareSize + 20;
                    const y = row * squareSize + 20;
                    const fill = (row + col) % 2 === 0 ? '#F5F5DC' : '#C19A6B';
                    const squareName = String.fromCharCode(97 + col) + (8 - row);
                    svg += `<rect x="${x}" y="${y}" width="${squareSize}" height="${squareSize}" fill="${fill}" 
                            data-square="${squareName}" onclick="handleSquareClick('${squareName}')" 
                            style="cursor: pointer;" />`;
                }
            }

            if (lastMove && chess) {
                const history = chess.history({ verbose: true });
                if (history.length > 0) {
                    const move = history[history.length - 1];
                    const fromCol = move.from.charCodeAt(0) - 97;
                    const fromRow = 8 - parseInt(move.from[1]);
                    const toCol = move.to.charCodeAt(0) - 97;
                    const toRow = 8 - parseInt(move.to[1]);

                    const fromX = fromCol * squareSize + 20;
                    const fromY = fromRow * squareSize + 20;
                    const toX = toCol * squareSize + 20;
                    const toY = toRow * squareSize + 20;

                    svg += `<rect x="${fromX}" y="${fromY}" width="${squareSize}" height="${squareSize}" fill="rgba(255, 255, 0, 0.4)" />`;
                    svg += `<rect x="${toX}" y="${toY}" width="${squareSize}" height="${squareSize}" fill="rgba(255, 255, 0, 0.4)" />`;
                }
            }

            if (selectedSquare) {
                const col = selectedSquare.charCodeAt(0) - 97;
                const row = 8 - parseInt(selectedSquare[1]);
                const x = col * squareSize + 20;
                const y = row * squareSize + 20;
                svg += `<rect x="${x}" y="${y}" width="${squareSize}" height="${squareSize}" fill="rgba(0, 123, 255, 0.3)" />`;
            }

            possibleMoves.forEach(move => {
                const col = move.to.charCodeAt(0) - 97;
                const row = 8 - parseInt(move.to[1]);
                const x = col * squareSize + 20;
                const y = row * squareSize + 20;
                const centerX = x + squareSize / 2;
                const centerY = y + squareSize / 2;
                
                if (chess.get(move.to)) {
                    svg += `<circle cx="${centerX}" cy="${centerY}" r="8" fill="rgba(220, 53, 69, 0.7)" />`;
                } else {
                    svg += `<circle cx="${centerX}" cy="${centerY}" r="6" fill="rgba(40, 167, 69, 0.7)" />`;
                }
            });

            if (lastStats.bestMove && lastStats.bestMove.length >= 4) {
                const from = lastStats.bestMove.substring(0, 2);
                const to = lastStats.bestMove.substring(2, 4);
                
                const fromCol = from.charCodeAt(0) - 97;
                const fromRow = 8 - parseInt(from[1]);
                const toCol = to.charCodeAt(0) - 97;
                const toRow = 8 - parseInt(to[1]);
                
                const fromX = (fromCol * squareSize) + squareSize/2 + 20;
                const fromY = (fromRow * squareSize) + squareSize/2 + 20;
                const toX = (toCol * squareSize) + squareSize/2 + 20;
                const toY = (toRow * squareSize) + squareSize/2 + 20;
                
                svg += `<defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#007bff" />
                    </marker>
                </defs>
                <line x1="${fromX}" y1="${fromY}" x2="${toX}" y2="${toY}" stroke="#007bff" 
                    stroke-width="3" opacity="0.8" marker-end="url(#arrowhead)" />`;
            }

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[7 - row][col];
                    if (piece) {
                        const x = col * squareSize + squareSize / 2 + 20;
                        const y = row * squareSize + squareSize / 2 + 42;
                        const symbol = pieceSymbols[piece] || '';
                        const squareName = String.fromCharCode(97 + col) + (8 - row);
                        svg += `<text x="${x}" y="${y}" font-size="48" text-anchor="middle" fill="#000" 
                                onclick="handleSquareClick('${squareName}')" style="cursor: pointer;">${symbol}</text>`;
                    }
                }
            }

            for (let i = 0; i < 8; i++) {
                svg += `<text x="10" y="${i * squareSize + squareSize / 1.5 + 20}" font-size="14" text-anchor="middle" fill="#666">${8 - i}</text>`;
                svg += `<text x="${i * squareSize + squareSize / 2 + 20}" y="${boardSize + 35}" font-size="14" text-anchor="middle" fill="#666">${String.fromCharCode(97 + i)}</text>`;
            }

            svg += '</svg>';
            return svg;
        }

        function showGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            if (!chess) return;

            let status = "";
            let iconClass = "fas fa-info-circle";
            let statusClass = "status-info";

            if (chess.in_checkmate()) {
                status = "¡Jaque mate!";
                iconClass = "fas fa-crown";
                statusClass = "status-danger";
            } else if (chess.in_stalemate()) {
                status = "Tablas por ahogado";
                iconClass = "fas fa-handshake";
                statusClass = "status-warning";
            } else if (chess.in_draw()) {
                if (chess.in_threefold_repetition()) {
                    status = "Tablas por repetición";
                } else if (chess.insufficient_material()) {
                    status = "Tablas por material";
                } else {
                    status = "Tablas por 50 movimientos";
                }
                iconClass = "fas fa-handshake";
                statusClass = "status-warning";
            } else if (chess.in_check()) {
                status = "¡Jaque!";
                iconClass = "fas fa-exclamation-triangle";
                statusClass = "status-warning";
            } else {
                status = chess.turn() === 'w' ? "Turno: Blancas" : "Turno: Negras";
                iconClass = "fas fa-chess";
                statusClass = "status-success";
            }

            statusElement.className = `game-status-compact ${statusClass}`;
            statusElement.innerHTML = `
                <i class="${iconClass}"></i>
                <span>${status}</span>
            `;
        }

        // ===================== FUNCIONES DE INTERACCIÓN CON EL TABLERO =====================
        function handleSquareClick(square) {
            if (gameMode === 'edit' || !chess) return;

            if (!selectedSquare) {
                const piece = chess.get(square);
                if (piece && canSelectPiece(piece)) {
                    selectedSquare = square;
                    possibleMoves = chess.moves({ square, verbose: true });
                    updateBoard();
                }
            } else {
                const moveObj = possibleMoves.find(m => m.to === square);
                if (moveObj) {
                    makeMove(moveObj.san);
                    return;
                }
                
                const piece = chess.get(square);
                if (piece && canSelectPiece(piece)) {
                    selectedSquare = square;
                    possibleMoves = chess.moves({ square, verbose: true });
                } else {
                    selectedSquare = null;
                    possibleMoves = [];
                }
                updateBoard();
            }
        }

        function canSelectPiece(piece) {
            if (!piece || !chess) return false;
            if (gameMode === 'human') {
                return piece.color === chess.turn();
            }
            if (gameMode === 'cpu') {
                return piece.color === (playerColor === 'white' ? 'w' : 'b') && piece.color === chess.turn();
            }
            return false;
        }

        function setGameMode(mode) {
            gameMode = mode;
            const select = document.getElementById('modeSelect');
            if (select && select.value !== mode) select.value = mode;
            selectedSquare = null;
            possibleMoves = [];
            updateButtonStates();
            
            addLog('info', `Modo cambiado a: ${mode === 'edit' ? 'Edición y análisis' : mode}`);
            
            reportAdaptiveModeStatus();
        }

        function updateBoard() {
            const chessboard = document.getElementById('chessboard');
            if (chessboard) {
                chessboard.innerHTML = generateChessboardSVG();
            }
        }

        function drawBoard() {
            const fen = document.getElementById('fenInput')?.value.trim();
            if (!fen) {
                alert('Por favor, ingresa una posición FEN válida.');
                return;
            }

            if (!window.Chess) {
                alert('Error: No se pudo cargar la biblioteca de ajedrez.');
                return;
            }

            chess = new Chess();
            const validation = chess.validate_fen(fen);
            if (!validation.valid) {
                alert(`Posición FEN inválida: ${validation.error}`);
                return;
            }

            chess.load(fen);
            parseFEN(fen);
            
            lastStats = {
                nps: 0,
                pv: '',
                pvs: {},
                evaluation: null,
                depth: 0,
                bestMove: '',
                bestMoveSan: '',
                nodes: 0,
                time: 0
            };
            
            selectedSquare = null;
            possibleMoves = [];
            updateBoard();
            
            document.getElementById('legalMoves').style.display = 'none';
            lastMove = null;
            showGameStatus();
            updateButtonStates();
            
            document.getElementById('evaluation').textContent = '--';
            document.getElementById('bestMove').textContent = '--';
            document.getElementById('engineStats').textContent = '--';
            document.getElementById('pvLine').textContent = 'Inicia el análisis para ver la mejor línea';
            
            resetHighlights();
            
            if (isAnalyzing) {
                stopAnalysis();
            }
            
            updateMemoryStats();
            setupPVObserver();
            
            addLog('success', 'Posición cargada correctamente');
            reportAdaptiveModeStatus();
        }

        function makeMove(move) {
            if (!chess) return;

            try {
                const moveResult = chess.move(move);
                if (!moveResult) {
                    console.warn('Movimiento inválido:', move);
                    return;
                }
                
                lastMove = moveResult;
                document.getElementById('fenInput').value = chess.fen();
                parseFEN(chess.fen());
                
                selectedSquare = null;
                possibleMoves = [];
                updateBoard();
                
                showLegalMoves();
                showGameStatus();
                updateButtonStates();
                
                if (isAnalyzing) {
                    stopAnalysis();
                }
                
                resetStats();
                resetAnalysisDisplay();
                
                addLog('success', `Movimiento: ${moveResult.san}`);
                
                if (isEngineConnected && !chess.game_over()) {
                    setTimeout(() => {
                        const cpuTurn = gameMode === 'cpu' && chess.turn() !== (playerColor === 'white' ? 'w' : 'b');
                        if (cpuTurn) {
                            startAdaptiveAnalysis();
                        }
                    }, 500);
                }
                
                updateMemoryStats();
                setTimeout(setupPVObserver, 100);
                
            } catch (error) {
                console.error('Error al hacer movimiento:', error);
                addLog('warning', `Error en movimiento: ${error.message}`);
            }
        }

        /**
 * Reinicia todas las estadísticas y estructuras de datos del sistema de análisis
 * 
 * Esta función actualizada incluye la inicialización de las nuevas estructuras
 * de datos requeridas por el sistema adaptativo de búsqueda de equilibrio.
 */
function resetStats() {
    lastStats = {
        // ===================== ESTADÍSTICAS BÁSICAS DEL MOTOR =====================
        nps: 0,                    // Nodos por segundo
        nodes: 0,                  // Total de nodos analizados
        time: 0,                   // Tiempo de análisis en milisegundos
        depth: 0,                  // Profundidad de búsqueda actual
        
        // ===================== DATOS DE VARIANTES PRINCIPALES =====================
        pv: '',                    // Línea principal por defecto (PV 1)
        pvs: {},                   // Todas las líneas PV: {1: "e2e4 e7e5...", 2: "d2d4..."}
        pvEvaluations: {},         // Evaluaciones por PV: {1: {value: 23, type: "cp"}, 2: {...}}
        
        // ===================== EVALUACIÓN PRINCIPAL Y MEJOR MOVIMIENTO =====================
        evaluation: null,          // Evaluación principal (del PV 1)
        bestMove: '',              // Mejor movimiento en formato UCI (ej: "e2e4")
        bestMoveSan: '',           // Mejor movimiento en notación algebraica (ej: "e4")
        
        // ===================== METADATOS Y DIAGNÓSTICO =====================
        lastUpdateTimestamp: Date.now(),    // Momento de la última actualización
        analysisMode: 'standard',           // 'standard' o 'adaptive'
        totalPVsReceived: 0,                // Contador total de PVs recibidos
        
        // ===================== MÉTRICAS DEL SISTEMA ADAPTATIVO =====================
        adaptiveMetrics: {
            iterationsCompleted: 0,          // Número de iteraciones del proceso adaptativo
            bestEquilibriumFound: Infinity,  // Mejor equilibrio encontrado hasta ahora
            searchStartTime: null,           // Momento de inicio de la búsqueda actual
            totalVariantsAnalyzed: 0,        // Total de variantes analizadas
            fallbacksUsed: 0                 // Número de veces que se usaron fallbacks
        }
    };
    
    // ===================== REINICIO DEL ESTADO DE ANÁLISIS PROGRESIVO =====================
    currentPVAnalysis = {
        pvCount: 10,                    // Número de variantes principales a analizar (actualizado)
        depth: 1,                       // Profundidad inicial (actualizada)
        targetEvaluation: 0,            // Objetivo siempre es equilibrio perfecto
        searchInProgress: false,        // Estado de búsqueda
        adaptationActive: false,        // Estado del modo adaptativo
        
        // Nuevos campos para mejor control del proceso
        iterationCount: 0,              // Número de iteración actual
        lastIterationTime: null,        // Tiempo de la última iteración
        bestResultSoFar: null,          // Mejor resultado encontrado hasta ahora
        convergenceHistory: []          // Historial de convergencia hacia equilibrio
    };
    
    addLog('info', 'Estadísticas y estado adaptativo reiniciados');
}

/**
 * Función auxiliar para reiniciar solo las métricas adaptativas
 * 
 * Útil cuando se quiere mantener las estadísticas básicas del motor
 * pero reiniciar el proceso adaptativo específicamente.
 */
function resetAdaptiveMetrics() {
    if (lastStats && lastStats.adaptiveMetrics) {
        lastStats.adaptiveMetrics = {
            iterationsCompleted: 0,
            bestEquilibriumFound: Infinity,
            searchStartTime: Date.now(),
            totalVariantsAnalyzed: 0,
            fallbacksUsed: 0
        };
    }
    
    currentPVAnalysis.iterationCount = 0;
    currentPVAnalysis.lastIterationTime = null;
    currentPVAnalysis.bestResultSoFar = null;
    currentPVAnalysis.convergenceHistory = [];
    
    addLog('adaptation', 'Métricas adaptativas reiniciadas');
}

/**
 * Función para limpiar completamente el estado del sistema
 * 
 * Esta función es más agresiva que resetStats() y limpia también
 * elementos de la interfaz de usuario relacionados.
 */
function resetCompleteSystemState() {
    // Reiniciar estadísticas
    resetStats();
    
    // Limpiar visualización de análisis
    resetAnalysisDisplay();
    
    // Reiniciar destacado visual
    resetHighlights();
    
    // Limpiar estado de PV observer
    if (pvObserver) {
        pvObserver.disconnect();
        pvObserver = null;
    }
    
    // Reiniciar variables de estado de juego relacionadas
    selectedSquare = null;
    possibleMoves = [];
    lastMove = null;
    
    // Limpiar logs específicos del sistema adaptativo (opcional)
    const adaptiveLogs = logs.filter(log => log.type !== 'adaptation');
    if (adaptiveLogs.length !== logs.length) {
        addLog('info', `Eliminados ${logs.length - adaptiveLogs.length} logs adaptativos anteriores`);
        // logs = adaptiveLogs; // Descomenta si quieres limpiar logs adaptativos
    }
    
    addLog('success', 'Estado completo del sistema reiniciado');
}

        function resetAnalysisDisplay() {
            document.getElementById('evaluation').textContent = '--';
            document.getElementById('bestMove').textContent = '--';
            document.getElementById('engineStats').textContent = '--';
            document.getElementById('pvLine').textContent = 'Inicia el análisis para ver la mejor línea';
        }

        // ===================== MOTOR DE ANÁLISIS CON ADAPTACIÓN =====================
        function toggleEngine() {
            if (isEngineConnected) {
                disconnectEngine();
            } else {
                connectEngine();
            }
        }

        function toggleAnalysis() {
            if (isAnalyzing) {
                stopAnalysis();
            } else {
                if (gameMode === 'cpu') {
                    startEngineTurnIfNeeded();
                } else {
                    startAdaptiveAnalysis();
                }
            }
        }

        function startEngineTurnIfNeeded() {
            if (!chess) return;
            const cpuTurn = gameMode === 'cpu' && chess.turn() !== (playerColor === 'white' ? 'w' : 'b');
            if (!cpuTurn || chess.game_over()) return;

            if (isEngineConnected) {
                startAdaptiveAnalysis();
            } else {
                connectEngine();
            }
        }

        function startAdaptiveAnalysis() {
            if (!isEngineConnected || isAnalyzing || !chess || chess.game_over()) return;
            
            const adaptiveToggle = document.getElementById('adaptiveToggle');
            const adaptiveEnabled = adaptiveToggle ? adaptiveToggle.checked : true;
            
            if (adaptiveEnabled && (gameMode === 'cpu' || gameMode === 'edit')) {
                startProgressivePVSearch();
            } else {
                startStandardAnalysis();
            }
        }

        function startProgressivePVSearch() {
    currentPVAnalysis.searchInProgress = true;
    currentPVAnalysis.adaptationActive = true;
    currentPVAnalysis.pvCount = 10; // Cambiado de 3 a 10
    currentPVAnalysis.depth = 1;    // Cambiado de 6 a 1

    // El objetivo siempre es cero (equilibrio perfecto)
    currentPVAnalysis.targetEvaluation = 0;

    addLog('adaptation', `Iniciando búsqueda de equilibrio PV=${currentPVAnalysis.pvCount} Prof=${currentPVAnalysis.depth} objetivo=0.00`);
    
    executeProgressiveStep();
}

        function executeProgressiveStep() {
            if (!currentPVAnalysis.searchInProgress || !chess) return;
            
            const fen = chess.fen();
            lastStats.pvs = {};
            stockfish.postMessage(`setoption name MultiPV value ${currentPVAnalysis.pvCount}`);
            stockfish.postMessage(`position fen ${fen}`);
            stockfish.postMessage(`go depth ${currentPVAnalysis.depth}`);
            
            isAnalyzing = true;
            updateButtonStates();
            
            const engineStatus = document.getElementById('engineStatus');
            if (engineStatus) {
                engineStatus.textContent = `Búsqueda progresiva PV=${currentPVAnalysis.pvCount} Prof=${currentPVAnalysis.depth}...`;
            }

            addLog('info', `Analizando ${currentPVAnalysis.pvCount} líneas a profundidad ${currentPVAnalysis.depth}...`);
        }

            function startStandardAnalysis() {
            if (!isEngineConnected || isAnalyzing || !chess || chess.game_over()) return;

            const fen = chess.fen();
            lastStats.pvs = {};
            stockfish.postMessage('setoption name MultiPV value 1');
            stockfish.postMessage(`position fen ${fen}`);
            stockfish.postMessage('go infinite');
            
            isAnalyzing = true;
            
            const engineStatus = document.getElementById('engineStatus');
            if (engineStatus) {
                engineStatus.textContent = 'Análisis estándar en progreso...';
            }
            
            updateButtonStates();
            
            const pvLine = document.getElementById('pvLine');
            if (pvLine) pvLine.textContent = 'Analizando...';
            
            addLog('info', 'Análisis estándar iniciado');
        }

        function selectBestBalancedMove() {
    if (!lastStats.pvs || Object.keys(lastStats.pvs).length === 0) {
        return null;
    }

    let bestPV = null;
    let closestToZero = Infinity;
    let bestEvaluation = null;

    // Recorrer todas las variantes analizadas
    Object.keys(lastStats.pvs).forEach(pvNumber => {
        const pvLine = lastStats.pvs[pvNumber];
        
        // Obtener la evaluación de esta variante
        // (Aquí necesitarías acceso a las evaluaciones específicas de cada PV)
        const evaluation = getPVEvaluation(pvNumber);
        
        if (evaluation !== null) {
            const distance = Math.abs(evaluation);
            if (distance < closestToZero) {
                closestToZero = distance;
                bestPV = pvNumber;
                bestEvaluation = evaluation;
            }
        }
    });

    if (bestPV) {
        addLog('adaptation', `Seleccionada variante ${bestPV} con eval ${(bestEvaluation/100).toFixed(2)} (distancia: ${closestToZero}cp)`);
        return {
            pvNumber: bestPV,
            evaluation: bestEvaluation,
            line: lastStats.pvs[bestPV]
        };
    }

    return null;
}
        function forceBestMove() {
            if (!chess) return;
            addLog('warning', 'Forzando movimiento de CPU...');
            
            if (stockfish) {
                stockfish.postMessage('stop');
            }
            
            setTimeout(() => {
                if (lastStats.bestMoveSan) {
                    makeMove(lastStats.bestMoveSan);
                } else {
                    const legalMoves = chess.moves();
                    if (legalMoves.length > 0) {
                        const randomMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
                        makeMove(randomMove);
                        addLog('warning', `Movimiento aleatorio: ${randomMove}`);
                    }
                }
                
                isAnalyzing = false;
                currentPVAnalysis.searchInProgress = false;
                updateButtonStates();
            }, 200);
        }

        async function connectEngine() {
            if (isEngineConnected) return;

            try {
                document.getElementById('engineStatus').textContent = 'Conectando motor...';
                addLog('info', 'Conectando motor Stockfish...');
                
                const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js');
                if (!response.ok) {
                    throw new Error('Error al descargar Stockfish');
                }
                const workerScript = await response.text();

                const blob = new Blob([workerScript], { type: 'application/javascript' });
                blobURL = URL.createObjectURL(blob);

                stockfish = new Worker(blobURL);
                stockfish.onmessage = function(event) {
                    handleEngineMessage(event.data);
                };
                
                stockfish.postMessage('uci');
                stockfish.postMessage('setoption name MultiPV value 1');
                stockfish.postMessage('setoption name Hash value 128');
                stockfish.postMessage('isready');
                
                isEngineConnected = true;
                document.getElementById('engineStatus').textContent = 'Motor conectado y listo';
                updateButtonStates();
                
                addLog('success', 'Motor Stockfish conectado');
                
                if (chess && gameMode === 'cpu' && chess.turn() !== (playerColor === 'white' ? 'w' : 'b') && !chess.game_over()) {
                    setTimeout(() => {
                        startAdaptiveAnalysis();
                    }, 500);
                }
            } catch (error) {
                document.getElementById('engineStatus').textContent = 'Error: ' + error.message;
                isEngineConnected = false;
                updateButtonStates();
                addLog('warning', `Error conectando motor: ${error.message}`);
            }
        }
        
        function disconnectEngine() {
            if (!isEngineConnected) return;
            
            if (isAnalyzing) {
                stopAnalysis();
            }
            
            if (stockfish) {
                stockfish.terminate();
                stockfish = null;
            }
            
            if (blobURL) {
                URL.revokeObjectURL(blobURL);
                blobURL = null;
            }
            
            if (pvObserver) {
                pvObserver.disconnect();
                pvObserver = null;
            }
            
            isEngineConnected = false;
            currentPVAnalysis.searchInProgress = false;
            document.getElementById('engineStatus').textContent = 'Motor desconectado';
            resetAnalysisDisplay();
            resetHighlights();
            updateButtonStates();
            updateMemoryStats();
            
            addLog('info', 'Motor desconectado');
        }

        function stopAnalysis() {
            if (!isEngineConnected || !isAnalyzing) return;

            if (stockfish) {
                stockfish.postMessage('stop');
            }
            
            isAnalyzing = false;
            currentPVAnalysis.searchInProgress = false;
            document.getElementById('engineStatus').textContent = 'Motor conectado - Análisis detenido';
            updateButtonStates();
            
            addLog('info', 'Análisis detenido');
        }

        function handleEngineMessage(message) {
            if (message.startsWith('bestmove')) {
                processBestMove(message);
            } else if (message.startsWith('info')) {
                parseInfoLine(message);
            }
        }

        /**
 * Procesa el mensaje "bestmove" del motor Stockfish e implementa la lógica adaptativa
 * 
 * Esta función representa el núcleo de la toma de decisiones del sistema adaptativo.
 * En lugar de simplemente usar el mejor movimiento según el motor, evalúa todas
 * las variantes disponibles y selecciona aquella que mantenga mejor el equilibrio
 * de la posición cuando el modo adaptativo está activo.
 * 
 * @param {string} message - Mensaje del motor en formato "bestmove e2e4 ponder d7d5"
 */

// ===================== FUNCIONES DE ANÁLISIS DE EVALUACIONES =====================

/**
 * Obtiene la evaluación numérica para una variante principal específica
 * 
 * Esta función sirve como interfaz de acceso a las evaluaciones almacenadas
 * por parseInfoLine(), proporcionando un punto centralizado para recuperar
 * valores de evaluación que serán utilizados por el algoritmo de selección
 * de movimientos equilibrados.
 * 
 * @param {number|string} pvNumber - Número de la variante principal (1-based)
 * @returns {number|null} - Valor de evaluación en centipawns, o null si no existe
 */
function getPVEvaluation(pvNumber) {
    // Verificar que tenemos la estructura de datos necesaria
    if (!lastStats.pvEvaluations) {
        return null;
    }
    
    // Convertir pvNumber a string para consistencia con las claves del objeto
    const pvKey = pvNumber.toString();
    
    // Verificar que existe la evaluación para esta variante específica
    if (!lastStats.pvEvaluations[pvKey]) {
        return null;
    }
    
    const evaluationData = lastStats.pvEvaluations[pvKey];
    
    // Retornar el valor numérico que ya fue procesado y ajustado por parseInfoLine
    // Este valor está en centipawns y ya tiene el signo correcto según el turno
    return evaluationData.value;
}

/**
 * Función auxiliar para obtener información detallada de una evaluación PV
 * 
 * Útil para debugging y logging detallado del proceso adaptativo.
 * Retorna toda la información disponible sobre la evaluación de una variante.
 * 
 * @param {number|string} pvNumber - Número de la variante principal
 * @returns {Object|null} - Objeto con información completa o null si no existe
 */
function getPVEvaluationDetails(pvNumber) {
    if (!lastStats.pvEvaluations) {
        return null;
    }
    
    const pvKey = pvNumber.toString();
    
    if (!lastStats.pvEvaluations[pvKey]) {
        return null;
    }
    
    // Retornar una copia del objeto para evitar modificaciones accidentales
    return { ...lastStats.pvEvaluations[pvKey] };
}

/**
 * Función de utilidad para verificar si tenemos evaluaciones válidas
 * 
 * Esta función es particularmente útil antes de iniciar procesos de selección
 * de movimientos equilibrados, ya que nos permite verificar que tenemos
 * suficientes datos para tomar decisiones informadas.
 * 
 * @returns {boolean} - true si tenemos al menos una evaluación válida
 */
function hasValidPVEvaluations() {
    if (!lastStats.pvEvaluations) {
        return false;
    }
    
    // Contar cuántas evaluaciones válidas tenemos
    const validEvaluations = Object.keys(lastStats.pvEvaluations).filter(pvKey => {
        const evalData = lastStats.pvEvaluations[pvKey];
        return evalData && typeof evalData.value === 'number';
    });
    
    return validEvaluations.length > 0;
}

/**
 * Función para obtener el número total de evaluaciones disponibles
 * 
 * Útil para determinar si hemos recibido suficientes variantes para
 * realizar un análisis adaptativo completo.
 * 
 * @returns {number} - Número de evaluaciones PV disponibles
 */
function getAvailablePVCount() {
    if (!lastStats.pvEvaluations) {
        return 0;
    }
    
    return Object.keys(lastStats.pvEvaluations).length;
}

/**
 * Evalúa la calidad de una jugada basada en su distancia del equilibrio perfecto
 * 
 * Esta función proporciona una clasificación cualitativa que ayuda tanto al sistema
 * como al usuario a entender qué tan exitoso ha sido el proceso de búsqueda de equilibrio.
 * Los umbrales están diseñados para reflejar niveles prácticos de equilibrio en ajedrez.
 * 
 * @param {number} distanceFromZero - Distancia en centipawns del equilibrio perfecto (valor absoluto)
 * @returns {string} - Clasificación cualitativa del nivel de equilibrio
 */
function assessMoveQuality(distanceFromZero) {
    // Verificar que el parámetro sea válido
    if (typeof distanceFromZero !== 'number' || distanceFromZero < 0) {
        return 'Evaluación inválida';
    }
    
    // Clasificar según umbrales cuidadosamente calibrados
    if (distanceFromZero <= 10) {
        return 'EQUILIBRIO PERFECTO';      // Prácticamente igual, excelente resultado
    } else if (distanceFromZero <= 25) {
        return 'Muy equilibrada';          // Diferencia mínima, muy buen resultado
    } else if (distanceFromZero <= 50) {
        return 'Razonablemente equilibrada'; // Diferencia pequeña, resultado aceptable
    } else if (distanceFromZero <= 100) {
        return 'Moderadamente desequilibrada'; // Diferencia notable pero no crítica
    } else if (distanceFromZero <= 200) {
        return 'Significativamente desequilibrada'; // Diferencia considerable
    } else if (distanceFromZero <= 400) {
        return 'Altamente desequilibrada'; // Gran diferencia, resultado subóptimo
    } else {
        return 'Extremadamente desequilibrada'; // Diferencia muy grande
    }
}

/**
 * Selecciona la variante principal que produce la evaluación más cercana al equilibrio
 * 
 * Esta función implementa el núcleo del algoritmo adaptativo equilibrado,
 * analizando todas las variantes disponibles para encontrar la que mejor
 * mantiene el balance de la posición. El objetivo es siempre alcanzar
 * una evaluación de 0.00 (equilibrio perfecto).
 * 
 * @returns {Object|null} - Información de la mejor variante equilibrada o null
 */

/**
 * Analiza la distribución estadística de las evaluaciones disponibles
 * 
 * Esta función proporciona métricas importantes sobre qué tan diversas son
 * las opciones que el motor de ajedrez está proporcionando. Una buena
 * distribución con múltiples opciones equilibradas indica que el sistema
 * adaptativo tiene mejores posibilidades de encontrar jugadas balanceadas.
 * 
 * @returns {Object|null} - Estadísticas detalladas o null si no hay datos suficientes
 */
function analyzeEvaluationDistribution() {
    // Verificar que tenemos evaluaciones válidas para analizar
    if (!hasValidPVEvaluations()) {
        return null;
    }
    
    // Extraer todos los valores de evaluación disponibles
    const evaluations = Object.keys(lastStats.pvEvaluations).map(pvNum => {
        return getPVEvaluation(pvNum);
    }).filter(eval => eval !== null && typeof eval === 'number');
    
    // Verificar que tenemos suficientes datos para análisis estadístico
    if (evaluations.length === 0) {
        return null;
    }
    
    // Calcular estadísticas descriptivas básicas
    const min = Math.min(...evaluations);
    const max = Math.max(...evaluations);
    const avg = evaluations.reduce((sum, eval) => sum + eval, 0) / evaluations.length;
    const range = max - min;
    
    // Calcular mediana para entender la distribución central
    const sortedEvaluations = [...evaluations].sort((a, b) => a - b);
    const median = evaluations.length % 2 === 0 
        ? (sortedEvaluations[evaluations.length / 2 - 1] + sortedEvaluations[evaluations.length / 2]) / 2
        : sortedEvaluations[Math.floor(evaluations.length / 2)];
    
    // Contar evaluaciones por categorías de equilibrio
    const veryBalanced = evaluations.filter(eval => Math.abs(eval) <= 25).length;
    const reasonablyBalanced = evaluations.filter(eval => Math.abs(eval) <= 50).length;
    const moderatelyBalanced = evaluations.filter(eval => Math.abs(eval) <= 100).length;
    
    // Calcular desviación estándar para medir dispersión
    const variance = evaluations.reduce((sum, eval) => sum + Math.pow(eval - avg, 2), 0) / evaluations.length;
    const standardDeviation = Math.sqrt(variance);
    
    // Identificar evaluaciones extremas (outliers)
    const outlierThreshold = 2 * standardDeviation;
    const outliers = evaluations.filter(eval => Math.abs(eval - avg) > outlierThreshold);
    
    return {
        // Estadísticas básicas
        totalEvaluations: evaluations.length,
        minEval: min,
        maxEval: max,
        averageEval: avg,
        medianEval: median,
        range: range,
        standardDeviation: standardDeviation,
        
        // Análisis de equilibrio por categorías
        veryBalancedCount: veryBalanced,
        reasonablyBalancedCount: reasonablyBalanced,
        moderatelyBalancedCount: moderatelyBalanced,
        
        // Porcentajes para interpretación fácil
        veryBalancedPercentage: (veryBalanced / evaluations.length) * 100,
        reasonablyBalancedPercentage: (reasonablyBalanced / evaluations.length) * 100,
        moderatelyBalancedPercentage: (moderatelyBalanced / evaluations.length) * 100,
        
        // Información sobre outliers
        outliersCount: outliers.length,
        outliersPercentage: (outliers.length / evaluations.length) * 100,
        
        // Evaluación cualitativa general
        distributionQuality: assessDistributionQuality(veryBalanced, reasonablyBalanced, evaluations.length)
    };
}

/**
 * Función auxiliar para evaluar la calidad general de la distribución
 */
function assessDistributionQuality(veryBalanced, reasonablyBalanced, total) {
    const reasonablePercentage = (reasonablyBalanced / total) * 100;
    
    if (reasonablePercentage >= 60) {
        return 'Excelente diversidad de opciones equilibradas';
    } else if (reasonablePercentage >= 40) {
        return 'Buena diversidad de opciones';
    } else if (reasonablePercentage >= 20) {
        return 'Diversidad moderada';
    } else {
        return 'Opciones limitadas para equilibrio';
    }
}

/**
 * Extrae el primer movimiento de una línea de variante principal (PV) en formato UCI
 * 
 * Esta función es crucial para el sistema adaptativo porque permite convertir
 * la línea de análisis seleccionada en un movimiento ejecutable. Maneja la
 * conversión de notación algebraica estándar (SAN) a notación UCI y valida
 * que el movimiento sea legal en la posición actual.
 * 
 * @param {string} pvLine - Línea PV en formato SAN (ej: "1. Nf3 d5 2. g3 Nf6...")
 * @returns {string|null} - Movimiento en formato UCI (ej: "g1f3") o null si error
 */
function extractFirstMoveFromPVLine(pvLine) {
    // Validación básica de parámetros de entrada
    if (!pvLine || typeof pvLine !== 'string' || pvLine.trim().length === 0) {
        addLog('warning', 'Línea PV vacía o inválida para extracción de movimiento');
        return null;
    }
    
    if (!chess) {
        addLog('warning', 'Objeto chess no inicializado para extracción de movimiento');
        return null;
    }
    
    try {
        // Crear una copia temporal del estado del juego para no afectar el original
        const tempChess = new Chess(chess.fen());
        
        // Limpiar y tokenizar la línea PV
        const cleanLine = pvLine.trim();
        
        // Dividir en tokens y filtrar elementos irrelevantes
        const tokens = cleanLine.split(/\s+/).filter(token => {
            // Eliminar números de movimiento (ej: "1.", "2.", "1...", etc.)
            if (token.match(/^\d+\.+$/)) {
                return false;
            }
            
            // Mantener solo tokens que parezcan movimientos de ajedrez válidos
            return token.match(/^[a-h1-8KQRBNOX+#=\-]+$/) && token.length >= 2;
        });
        
        if (tokens.length === 0) {
            addLog('warning', `No se encontraron movimientos válidos en línea PV: "${cleanLine}"`);
            return null;
        }
        
        // El primer token debería ser nuestro movimiento objetivo
        const firstMoveToken = tokens[0];
        
        addLog('info', `Intentando extraer movimiento: "${firstMoveToken}" de línea: "${cleanLine.substring(0, 30)}${cleanLine.length > 30 ? '...' : ''}"`);
        
        // Intentar ejecutar el movimiento en el tablero temporal
        const moveResult = tempChess.move(firstMoveToken, { sloppy: true });
        
        if (moveResult) {
            // Construir el movimiento en formato UCI
            const uciMove = moveResult.from + moveResult.to + (moveResult.promotion || '');
            
            // Validación adicional: verificar que el movimiento es realmente legal
            const validationChess = new Chess(chess.fen());
            const validationMove = validationChess.move(firstMoveToken, { sloppy: true });
            
            if (!validationMove) {
                addLog('warning', `Movimiento "${firstMoveToken}" no es válido en posición actual`);
                return null;
            }
            
            // Verificación de consistencia entre tableros temporal y de validación
            if (validationMove.from !== moveResult.from || validationMove.to !== moveResult.to) {
                addLog('warning', `Inconsistencia en movimiento: temp=${moveResult.from}${moveResult.to}, valid=${validationMove.from}${validationMove.to}`);
                return null;
            }
            
            addLog('success', `Movimiento extraído exitosamente: ${firstMoveToken} → ${uciMove}`);
            return uciMove;
            
        } else {
            // Si el primer token falló, intentar con estrategias alternativas
            addLog('info', `Primer token "${firstMoveToken}" falló, probando estrategias alternativas...`);
            
            // Estrategia alternativa: Intentar parsing manual de notación
            const manualUci = attemptManualNotationParsing(firstMoveToken, tempChess);
            if (manualUci) {
                addLog('adaptation', `Parsing manual exitoso: ${firstMoveToken} → ${manualUci}`);
                return manualUci;
            }
            
            addLog('warning', `No se pudo convertir "${firstMoveToken}" a movimiento válido`);
            return null;
        }
        
    } catch (error) {
        addLog('warning', `Error procesando línea PV "${pvLine}": ${error.message}`);
        console.warn('Error detallado en extractFirstMoveFromPVLine:', error);
        return null;
    }
}

/**
 * Intenta parsing manual de notación cuando el método automático falla
 */
function attemptManualNotationParsing(moveNotation, chessInstance) {
    try {
        // Enroque corto
        if (moveNotation === 'O-O' || moveNotation === '0-0') {
            const color = chessInstance.turn();
            if (color === 'w') {
                return 'e1g1';
            } else {
                return 'e8g8';
            }
        }
        
        // Enroque largo
        if (moveNotation === 'O-O-O' || moveNotation === '0-0-0') {
            const color = chessInstance.turn();
            if (color === 'w') {
                return 'e1c1';
            } else {
                return 'e8c8';
            }
        }
        
        // Intentar interpretación directa si parece formato UCI
        if (moveNotation.length === 4 && moveNotation.match(/^[a-h][1-8][a-h][1-8]$/)) {
            const testMove = chessInstance.move({
                from: moveNotation.substring(0, 2),
                to: moveNotation.substring(2, 4)
            });
            
            if (testMove) {
                chessInstance.undo();
                return moveNotation;
            }
        }
        
    } catch (error) {
        console.warn('Parsing manual falló:', error);
    }
    
    return null;
}

/**
 * Función de utilidad para validar un movimiento UCI contra la posición actual
 */
function validateUCIMove(uciMove) {
    if (!uciMove || !chess) {
        return false;
    }
    
    try {
        const tempChess = new Chess(chess.fen());
        
        if (uciMove.length === 4) {
            const move = tempChess.move({
                from: uciMove.substring(0, 2),
                to: uciMove.substring(2, 4)
            });
            return move !== null;
        } else if (uciMove.length === 5) {
            const move = tempChess.move({
                from: uciMove.substring(0, 2),
                to: uciMove.substring(2, 4),
                promotion: uciMove[4].toLowerCase()
            });
            return move !== null;
        }
        
        return false;
        
    } catch (error) {
        return false;
    }
}

// ===================== FIN DE FUNCIONES DE ANÁLISIS DE EVALUACIONES =====================
        
    function processBestMove(message) {
    const parts = message.split(' ');
    const engineBestMove = parts[1];
    
    // Validación básica del mensaje del motor
    if (!engineBestMove || engineBestMove === '(none)') {
        addLog('warning', 'Motor no proporcionó movimiento válido');
        isAnalyzing = false;
        currentPVAnalysis.searchInProgress = false;
        updateButtonStates();
        return;
    }
    
    addLog('info', `Motor sugiere: ${engineBestMove}`);
    
    // ===================== LÓGICA DE SELECCIÓN ADAPTATIVA =====================
    
    let selectedMove = null;
    let selectedMoveSAN = null;
    let selectedEvaluation = lastStats.evaluation;
    let adaptiveReason = '';
    
    // Determinar si aplicar lógica adaptativa
    if (currentPVAnalysis.adaptationActive && hasValidPVEvaluations()) {
        addLog('adaptation', 'Aplicando selección adaptativa de movimiento...');
        
        // Intentar encontrar el movimiento más equilibrado
        const balancedMove = selectBestBalancedMove();
        
        if (balancedMove && balancedMove.pvNumber) {
            // Extraer el movimiento UCI de la línea seleccionada
            const extractedUCI = extractFirstMoveFromPVLine(balancedMove.line);
            
            if (extractedUCI && validateUCIMove(extractedUCI)) {
                // Movimiento adaptativo válido encontrado
                selectedMove = extractedUCI;
                selectedMoveSAN = uciToSan(extractedUCI);
                selectedEvaluation = {
                    value: balancedMove.evaluation,
                    type: Math.abs(balancedMove.evaluation) > 900 ? 'mate' : 'cp'
                };
                
                const distanceFromZero = Math.abs(balancedMove.evaluation);
                adaptiveReason = `Adaptativo: PV${balancedMove.pvNumber} equilibrio ${(balancedMove.evaluation/100).toFixed(2)} (Δ${distanceFromZero}cp)`;
                
                // Comparar con la sugerencia original del motor
                const originalEval = lastStats.evaluation ? lastStats.evaluation.value : 0;
                const originalDistance = Math.abs(originalEval);
                const improvementGap = originalDistance - distanceFromZero;
                
                if (improvementGap > 25) {
                    addLog('adaptation', `Mejora significativa: ${improvementGap}cp más equilibrado que motor (${(originalEval/100).toFixed(2)} → ${(balancedMove.evaluation/100).toFixed(2)})`);
                } else if (improvementGap > 0) {
                    addLog('adaptation', `Mejora marginal: ${improvementGap}cp más equilibrado que motor`);
                } else if (improvementGap < -10) {
                    addLog('warning', `Selección subóptima: ${Math.abs(improvementGap)}cp menos equilibrado que motor`);
                }
                
            } else {
                // Fallback: movimiento extraído no es válido
                addLog('warning', `Movimiento adaptativo inválido: ${extractedUCI}, usando motor`);
                selectedMove = engineBestMove;
                selectedMoveSAN = uciToSan(engineBestMove);
                adaptiveReason = 'Fallback al motor (extracción fallida)';
            }
            
        } else {
            // Fallback: no se pudo encontrar movimiento equilibrado
            addLog('warning', 'No se encontró movimiento equilibrado válido, usando motor');
            selectedMove = engineBestMove;
            selectedMoveSAN = uciToSan(engineBestMove);
            adaptiveReason = 'Fallback al motor (sin opciones equilibradas)';
        }
        
        // Análisis estadístico del proceso adaptativo
        const analysisStats = analyzeEvaluationDistribution();
        if (analysisStats && Math.random() < 0.4) {
            addLog('info', `Análisis: ${analysisStats.totalEvaluations} variantes, ${analysisStats.reasonablyBalancedCount} equilibradas (${analysisStats.balancePercentage.toFixed(1)}%)`);
        }
        
    } else {
        // ===================== MODO ESTÁNDAR (NO ADAPTATIVO) =====================
        
        selectedMove = engineBestMove;
        selectedMoveSAN = uciToSan(engineBestMove);
        
        if (currentPVAnalysis.adaptationActive) {
            adaptiveReason = 'Sin datos PV suficientes para adaptación';
        } else {
            adaptiveReason = 'Modo estándar activo';
        }
        
        addLog('info', `Usando movimiento estándar del motor: ${selectedMoveSAN}`);
    }
    
    // ===================== ACTUALIZACIÓN DE ESTADO Y UI =====================
    
    // Actualizar estadísticas globales con la decisión final
    lastStats.bestMove = selectedMove;
    lastStats.bestMoveSan = selectedMoveSAN;
    
    // Si la evaluación fue modificada por el proceso adaptativo, actualizarla
    if (selectedEvaluation && selectedEvaluation !== lastStats.evaluation) {
        lastStats.evaluation = selectedEvaluation;
    }
    
    // Actualizar interfaz de usuario
    const bestMoveElement = document.getElementById('bestMove');
    if (bestMoveElement) {
        bestMoveElement.textContent = `Mejor: ${selectedMoveSAN}`;
    }
    
    // Redibujar tablero con el nuevo movimiento destacado
    updateBoard();
    
    // Log de la decisión final
    if (adaptiveReason) {
        addLog('success', `Decisión final: ${selectedMoveSAN} - ${adaptiveReason}`);
    } else {
        addLog('success', `Mejor movimiento encontrado: ${selectedMoveSAN}`);
    }
    
    // ===================== PROCESAMIENTO POST-DECISIÓN =====================
    
    // Evaluar si necesitamos continuar con más análisis adaptativo
    if (currentPVAnalysis.adaptationActive) {
        evaluateAdaptationResult();
    }
    
    // ===================== MANEJO ESPECÍFICO POR MODO DE JUEGO =====================
    
    if (gameMode === 'cpu') {
        // En modo CPU, ejecutar el movimiento automáticamente después de una pausa
        addLog('info', 'CPU ejecutará el movimiento seleccionado...');
        
        // Detener análisis antes de ejecutar movimiento
        stopAnalysis();
        
        if (selectedMoveSAN) {
            setTimeout(() => {
                makeMove(selectedMoveSAN);
            }, 300);
        } else {
            // Fallback de emergencia: movimiento aleatorio
            addLog('warning', 'Error crítico: ejecutando movimiento aleatorio');
            const legalMoves = chess.moves();
            if (legalMoves.length > 0) {
                const randomMove = legalMoves[Math.floor(Math.random() * legalMoves.length)];
                setTimeout(() => {
                    makeMove(randomMove);
                }, 300);
            }
        }
        
    } else {
        // En otros modos, el movimiento queda como sugerencia
        addLog('info', `Movimiento sugerido disponible: ${selectedMoveSAN}`);
    }
    
    // ===================== MÉTRICAS Y DIAGNÓSTICO =====================
    
    // Actualizar métricas de rendimiento
    updateEnginePerformanceMetrics();
    
    // Verificar integridad del estado después del procesamiento
    validateSystemState();
}

/**
 * Actualiza métricas de rendimiento del motor y sistema adaptativo
 * 
 * Esta función recopila estadísticas sobre el rendimiento del análisis
 * para ayudar en el diagnóstico y optimización del sistema.
 */

        /**
 * Evalúa la calidad de una jugada basada en su distancia del equilibrio perfecto
 * 
 * Esta función proporciona una clasificación cualitativa que ayuda tanto al sistema
 * como al usuario a entender qué tan exitoso ha sido el proceso de búsqueda de equilibrio.
 * Los umbrales están diseñados para reflejar niveles prácticos de equilibrio en ajedrez.
 * 
 * @param {number} distanceFromZero - Distancia en centipawns del equilibrio perfecto (valor absoluto)
 * @returns {string} - Clasificación cualitativa del nivel de equilibrio
 */

function updateEnginePerformanceMetrics() {
    if (!lastStats) return;
    
    // Calcular eficiencia del análisis
    const analysisEfficiency = {
        nodesPerSecond: lastStats.nps,
        totalNodes: lastStats.nodes,
        analysisTime: lastStats.time,
        depth: lastStats.depth,
        pvCount: getAvailablePVCount()
    };
    
    // Actualizar display de estadísticas si es necesario
    const engineStatsEl = document.getElementById('engineStats');
    if (engineStatsEl && Math.random() < 0.3) {
        const efficiency = analysisEfficiency.nodesPerSecond > 0 ? 
            `${(analysisEfficiency.nodesPerSecond / 1000).toFixed(0)}k n/s` : 'N/A';
        engineStatsEl.textContent = `Prof: ${analysisEfficiency.depth} | ${efficiency} | PV: ${analysisEfficiency.pvCount}`;
    }
}

/**
 * Valida la integridad del estado del sistema después de procesamiento
 * 
 * Esta función realiza verificaciones de sanidad para asegurar que
 * el sistema esté en un estado consistente después de tomar decisiones.
 */
function validateSystemState() {
    let issuesFound = 0;
    
    // Verificar que tenemos un movimiento válido
    if (!lastStats.bestMove || !lastStats.bestMoveSan) {
        addLog('warning', 'Estado inconsistente: falta información de mejor movimiento');
        issuesFound++;
    }
    
    // Verificar que la evaluación es coherente
    if (lastStats.evaluation && typeof lastStats.evaluation.value !== 'number') {
        addLog('warning', 'Estado inconsistente: evaluación inválida');
        issuesFound++;
    }
    
    // Verificar coherencia entre PVs y evaluaciones
    if (lastStats.pvs && lastStats.pvEvaluations) {
        const pvCount = Object.keys(lastStats.pvs).length;
        const evalCount = Object.keys(lastStats.pvEvaluations).length;
        
        if (Math.abs(pvCount - evalCount) > 1) {
            addLog('warning', `Inconsistencia: ${pvCount} PVs vs ${evalCount} evaluaciones`);
            issuesFound++;
        }
    }
    
    // Reportar estado si hay problemas
    if (issuesFound > 0) {
        addLog('warning', `Validación completada: ${issuesFound} problemas encontrados`);
    }
}

        /**
 * Evalúa el resultado del análisis adaptativo y decide si continuar o detener
 * 
 * Esta función controla el proceso iterativo de búsqueda de equilibrio,
 * determinando si el sistema ha encontrado una solución suficientemente
 * equilibrada o si necesita ajustar parámetros y continuar buscando.
 */
function evaluateAdaptationResult() {
    // Verificar que el modo adaptativo sigue activo
    if (!currentPVAnalysis.adaptationActive) {
        addLog('info', 'Evaluación de adaptación omitida: modo no activo');
        return;
    }
    
    // Buscar la mejor opción equilibrada actual
    const balancedMove = selectBestBalancedMove();
    if (!balancedMove) {
        addLog('warning', 'No se puede evaluar adaptación: sin movimientos equilibrados disponibles');
        handleAdaptationFailure();
        return;
    }
    
    const currentEval = balancedMove.evaluation;
    const distance = Math.abs(currentEval);
    
    // Configuración de parámetros adaptativos
    const EQUILIBRIUM_THRESHOLD = 25; // Umbral de equilibrio aceptable (25 centipawns)
    const MAX_DEPTH = 15; // Profundidad máxima (reducida desde niveles anteriores)
    const MIN_DEPTH = 1;  // Profundidad mínima
    const DEPTH_STEP = 1; // Incremento de profundidad
    const ITERATION_DELAY = 600; // Delay entre iteraciones (ms)
    
    addLog('adaptation', `Evaluando: eval=${(currentEval/100).toFixed(2)}, distancia=${distance}cp, prof=${currentPVAnalysis.depth}`);
    
    // ===================== CRITERIOS DE FINALIZACIÓN =====================
    
    if (distance <= EQUILIBRIUM_THRESHOLD) {
        // ¡Equilibrio encontrado!
        const quality = assessMoveQuality(distance);
        const stats = balancedMove.statisticalContext;
        
        addLog('success', `🎯 EQUILIBRIO ALCANZADO: ${(currentEval/100).toFixed(2)} (${quality})`);
        addLog('adaptation', `Estadísticas finales: prof=${currentPVAnalysis.depth}, PVs=${getAvailablePVCount()}, avg_dist=${stats?.avgDistance?.toFixed(0)}cp`);
        
        // Finalizar proceso adaptativo
        currentPVAnalysis.adaptationActive = false;
        currentPVAnalysis.searchInProgress = false;
        
        // Actualizar interfaz
        const engineStatus = document.getElementById('engineStatus');
        if (engineStatus) {
            engineStatus.textContent = `Equilibrio alcanzado - Prof: ${currentPVAnalysis.depth} - ${quality}`;
        }
        
        // Métricas de éxito
        trackAdaptationSuccess(distance, currentPVAnalysis.depth, getAvailablePVCount());
        return;
    }
    
    // ===================== ESTRATEGIAS DE CONTINUACIÓN =====================
    
    if (currentPVAnalysis.depth < MAX_DEPTH) {
        // Estrategia: Aumentar profundidad para encontrar mejor equilibrio
        currentPVAnalysis.depth += DEPTH_STEP;
        
        const newDepthReason = distance > 100 ? 
            'Gran desequilibrio detectado' : 
            'Refinando búsqueda de equilibrio';
            
        addLog('adaptation', `📈 Aumentando profundidad a ${currentPVAnalysis.depth} (${newDepthReason}, Δ${distance}cp)`);
        
        // Reiniciar búsqueda con nueva profundidad
        setTimeout(() => {
            if (currentPVAnalysis.searchInProgress) {
                executeProgressiveStep();
            }
        }, ITERATION_DELAY);
        
    } else {
        // ===================== LÍMITE DE PROFUNDIDAD ALCANZADO =====================
        
        // Evaluar si el resultado actual es aceptable
        const isReasonablyBalanced = distance <= 50;
        const isSignificantlyBetter = evaluateImprovementOverStandard(currentEval);
        
        if (isReasonablyBalanced || isSignificantlyBetter) {
            // Resultado aceptable aunque no perfecto
            const finalQuality = assessMoveQuality(distance);
            
            addLog('adaptation', `✅ Finalizando con resultado aceptable: ${(currentEval/100).toFixed(2)} (${finalQuality})`);
            addLog('info', `Límite de profundidad alcanzado (${MAX_DEPTH}), manteniendo mejor equilibrio encontrado`);
            
        } else {
            // Resultado no satisfactorio
            addLog('warning', `⚠️ Límite alcanzado sin equilibrio ideal: ${(currentEval/100).toFixed(2)} (Δ${distance}cp)`);
            addLog('adaptation', 'Considerando alternativas de fallback...');
            
            // Intentar estrategia de fallback
            const fallbackResult = attemptFallbackStrategy();
            if (fallbackResult) {
                addLog('adaptation', `Fallback aplicado: ${fallbackResult}`);
            }
        }
        
        // Finalizar proceso independientemente del resultado
        currentPVAnalysis.adaptationActive = false;
        currentPVAnalysis.searchInProgress = false;
        
        // Actualizar interfaz con resultado final
        const engineStatus = document.getElementById('engineStatus');
        if (engineStatus) {
            const finalQuality = assessMoveQuality(distance);
            engineStatus.textContent = `Análisis completo - Prof: ${MAX_DEPTH} - ${finalQuality}`;
        }
        
        // Métricas de finalización
        trackAdaptationCompletion(distance, MAX_DEPTH, isReasonablyBalanced);
    }
}

/**
 * Maneja situaciones donde el proceso adaptativo no puede continuar
 */
function handleAdaptationFailure() {
    addLog('warning', 'Proceso adaptativo fallido: finalizando');
    
    currentPVAnalysis.adaptationActive = false;
    currentPVAnalysis.searchInProgress = false;
    
    // Intentar usar el mejor movimiento disponible del motor estándar
    if (lastStats.bestMove) {
        addLog('adaptation', 'Usando movimiento estándar como fallback');
    } else {
        addLog('warning', 'Sin movimientos disponibles - situación crítica');
    }
    
    const engineStatus = document.getElementById('engineStatus');
    if (engineStatus) {
        engineStatus.textContent = 'Error en proceso adaptativo - Usando fallback';
    }
}

/**
 * Evalúa si el movimiento adaptativo es significativamente mejor que el estándar
 * 
 * @param {number} adaptiveEval - Evaluación del movimiento adaptativo
 * @returns {boolean} - true si representa una mejora significativa
 */
function evaluateImprovementOverStandard(adaptiveEval) {
    // Comparar con la evaluación original del motor (PV 1)
    const originalEval = getPVEvaluation(1);
    
    if (originalEval === null) {
        return false; // No podemos comparar
    }
    
    const originalDistance = Math.abs(originalEval);
    const adaptiveDistance = Math.abs(adaptiveEval);
    const improvement = originalDistance - adaptiveDistance;
    
    // Considerar significativo si mejora el equilibrio en al menos 30 centipawns
    const isSignificantImprovement = improvement >= 30;
    
    if (isSignificantImprovement) {
        addLog('adaptation', `Mejora significativa vs motor: ${improvement}cp más equilibrado`);
    } else if (improvement > 0) {
        addLog('info', `Mejora marginal vs motor: ${improvement}cp más equilibrado`);
    } else {
        addLog('info', `Sin mejora vs motor: ${Math.abs(improvement)}cp diferencia`);
    }
    
    return isSignificantImprovement;
}

/**
 * Intenta estrategias de fallback cuando el análisis principal no logra equilibrio
 * 
 * @returns {string|null} - Descripción de la estrategia aplicada o null si falla
 */
function attemptFallbackStrategy() {
    // Estrategia 1: Buscar el movimiento menos desequilibrado disponible
    const allEvaluations = Object.keys(lastStats.pvEvaluations || {})
        .map(pvNum => ({
            pv: pvNum,
            eval: getPVEvaluation(pvNum),
            distance: Math.abs(getPVEvaluation(pvNum) || Infinity)
        }))
        .filter(item => item.eval !== null)
        .sort((a, b) => a.distance - b.distance);
    
    if (allEvaluations.length > 0) {
        const leastUnbalanced = allEvaluations[0];
        
        if (leastUnbalanced.distance < 100) {
            addLog('adaptation', `Fallback: usando PV${leastUnbalanced.pv} como menos desequilibrado (${(leastUnbalanced.eval/100).toFixed(2)})`);
            return `PV${leastUnbalanced.pv} seleccionado como menos desequilibrado`;
        }
    }
    
    // Estrategia 2: Usar movimiento estándar del motor si es razonablemente equilibrado
    const standardEval = getPVEvaluation(1);
    if (standardEval !== null && Math.abs(standardEval) < 150) {
        addLog('adaptation', `Fallback: movimiento estándar aceptable (${(standardEval/100).toFixed(2)})`);
        return 'Movimiento estándar del motor aceptado';
    }
    
    // Sin opciones de fallback viables
    return null;
}

/**
 * Registra métricas de éxito del proceso adaptativo
 */
function trackAdaptationSuccess(finalDistance, depth, pvCount) {
    const metrics = {
        success: true,
        finalDistance: finalDistance,
        depthUsed: depth,
        pvAnalyzed: pvCount,
        timestamp: Date.now()
    };
    
    // En un sistema más complejo, esto se guardaría para análisis posterior
    addLog('success', `Métricas de éxito: Δ${finalDistance}cp en prof.${depth} con ${pvCount} variantes`);
}

/**
 * Registra métricas de finalización del proceso adaptativo
 */
function trackAdaptationCompletion(finalDistance, maxDepth, wasAcceptable) {
    const metrics = {
        completed: true,
        finalDistance: finalDistance,
        maxDepthReached: maxDepth,
        resultAcceptable: wasAcceptable,
        timestamp: Date.now()
    };
    
    const status = wasAcceptable ? 'ACEPTABLE' : 'SUBÓPTIMO';
    addLog('info', `Adaptación completada: ${status} - Δ${finalDistance}cp en prof.${maxDepth}`);
}

        function parseInfoLine(message) {
    const parts = message.split(' ');

            /**
 * Obtiene la evaluación numérica para una variante principal específica
 * 
 * Esta función sirve como interfaz de acceso a las evaluaciones almacenadas
 * por parseInfoLine(), proporcionando un punto centralizado para recuperar
 * valores de evaluación que serán utilizados por el algoritmo de selección
 * de movimientos equilibrados.
 * 
 * @param {number|string} pvNumber - Número de la variante principal (1-based)
 * @returns {number|null} - Valor de evaluación en centipawns, o null si no existe
 */
/**
 * Función auxiliar para obtener información detallada de una evaluación PV
 * 
 * Útil para debugging y logging detallado del proceso adaptativo.
 * Retorna toda la información disponible sobre la evaluación de una variante.
 * 
 * @param {number|string} pvNumber - Número de la variante principal
 * @returns {Object|null} - Objeto con información completa o null si no existe
 */


/**
 * Función para obtener el número total de evaluaciones disponibles
 * 
 * Útil para determinar si hemos recibido suficientes variantes para
 * realizar un análisis adaptativo completo.
 * 
 * @returns {number} - Número de evaluaciones PV disponibles
 */
  
    // ===================== PROCESAMIENTO DE ESTADÍSTICAS BÁSICAS =====================
    
    // Extraer número de nodos analizados y tiempo transcurrido
    const nodesIndex = parts.indexOf('nodes');
    const timeIndex = parts.indexOf('time');
    if (nodesIndex !== -1 && timeIndex !== -1) {
        const nodes = parseInt(parts[nodesIndex + 1]);
        const time = parseInt(parts[timeIndex + 1]);
        lastStats.nodes = nodes;
        lastStats.time = time;
        
        // Calcular nodos por segundo (NPS) para monitorear rendimiento del motor
        if (time > 0) {
            lastStats.nps = Math.round(nodes / (time / 1000));
        }
    }
    
    // Extraer profundidad de búsqueda actual
    const depthIndex = parts.indexOf('depth');
    if (depthIndex !== -1) {
        lastStats.depth = parseInt(parts[depthIndex + 1]);
    }
    
    // ===================== PROCESAMIENTO DE EVALUACIONES POR VARIANTE =====================
    
    // Identificar si esta línea contiene información de evaluación (score)
    const scoreIndex = parts.indexOf('score');
    const multipvIndex = parts.indexOf('multipv');
    
    if (scoreIndex !== -1 && multipvIndex !== -1) {
        // Obtener el número de la variante principal (PV) que se está reportando
        const pvNumber = parseInt(parts[multipvIndex + 1]);
        const scoreType = parts[scoreIndex + 1]; // 'cp' para centipawns, 'mate' para mate
        const scoreValue = parseInt(parts[scoreIndex + 2]);
        
        // Inicializar estructura de evaluaciones por PV si no existe
        if (!lastStats.pvEvaluations) {
            lastStats.pvEvaluations = {};
        }
        
        // Procesar evaluación según su tipo
        if (scoreType === 'cp') {
            // Centipawns: ajustar signo según el turno actual
            // Valores positivos siempre representan ventaja para el jugador que mueve
            const adjustedEval = chess.turn() === 'w' ? scoreValue : -scoreValue;
            lastStats.pvEvaluations[pvNumber] = {
                value: adjustedEval,
                type: 'cp',
                rawValue: scoreValue, // Mantener valor original para debug
                turn: chess.turn()
            };
            
            // Logging detallado para debug del sistema adaptativo
            if (currentPVAnalysis.adaptationActive && Math.random() < 0.3) {
                addLog('info', `PV${pvNumber}: ${(adjustedEval/100).toFixed(2)} (raw: ${scoreValue}, turn: ${chess.turn()})`);
            }
            
        } else if (scoreType === 'mate') {
            // Mate en X movimientos: convertir a valor numérico muy alto
            const adjustedMate = chess.turn() === 'w' ? scoreValue : -scoreValue;
            
            // Convertir mate a centipawns equivalentes para facilitar comparaciones
            // Mate en 1 = ±10000, Mate en 2 = ±9000, etc.
            const mateValue = adjustedMate > 0 ? 
                (10000 - (adjustedMate * 100)) : 
                (-10000 + (Math.abs(adjustedMate) * 100));
                
            lastStats.pvEvaluations[pvNumber] = {
                value: mateValue,
                type: 'mate',
                mateIn: Math.abs(adjustedMate),
                rawValue: scoreValue,
                turn: chess.turn()
            };
            
            addLog('adaptation', `PV${pvNumber}: Mate en ${Math.abs(adjustedMate)} (valor: ${(mateValue/100).toFixed(2)})`);
        }
        
        // Actualizar evaluación principal con la información del PV 1
        // Esta será la evaluación que se muestra en la interfaz principal
        if (pvNumber === 1) {
            lastStats.evaluation = {
                value: lastStats.pvEvaluations[pvNumber].value,
                type: lastStats.pvEvaluations[pvNumber].type
            };
            
            // Si hay mate, agregar información específica
            if (lastStats.pvEvaluations[pvNumber].type === 'mate') {
                lastStats.evaluation.mateIn = lastStats.pvEvaluations[pvNumber].mateIn;
            }
        }
    }

            /**
 * Selecciona la variante principal que produce la evaluación más cercana al equilibrio
 * 
 * Esta función implementa el núcleo del algoritmo adaptativo equilibrado,
 * analizando todas las variantes disponibles para encontrar la que mejor
 * mantiene el balance de la posición. El objetivo es siempre alcanzar
 * una evaluación de 0.00 (equilibrio perfecto).
 * 
 * @returns {Object|null} - Información de la mejor variante equilibrada o null
 */
/**
 * Evalúa la calidad de una jugada basada en su distancia del equilibrio
 * 
 * Esta función proporciona una clasificación cualitativa que ayuda a entender
 * qué tan bien el sistema está logrando mantener el equilibrio deseado.
 * 
 * @param {number} distanceFromZero - Distancia en centipawns del equilibrio
 * @returns {string} - Clasificación cualitativa de la jugada
 */
function assessMoveQuality(distanceFromZero) {
    if (distanceFromZero <= 10) {
        return 'EQUILIBRIO PERFECTO';
    } else if (distanceFromZero <= 25) {
        return 'Muy equilibrada';
    } else if (distanceFromZero <= 50) {
        return 'Razonablemente equilibrada';
    } else if (distanceFromZero <= 100) {
        return 'Moderadamente desequilibrada';
    } else if (distanceFromZero <= 200) {
        return 'Significativamente desequilibrada';
    } else {
        return 'Altamente desequilibrada';
    }
}

/**
 * Función de diagnóstico para analizar la distribución de evaluaciones
 * 
 * Útil para entender qué tan diversas son las opciones que el motor
 * está proporcionando y si el sistema adaptativo tiene suficientes
 * alternativas para encontrar jugadas equilibradas.
 * 
 * @returns {Object} - Estadísticas sobre la distribución de evaluaciones
 */
/**
 * Analiza la distribución estadística de las evaluaciones disponibles
 * 
 * Esta función proporciona métricas importantes sobre qué tan diversas son
 * las opciones que el motor de ajedrez está proporcionando. Una buena
 * distribución con múltiples opciones equilibradas indica que el sistema
 * adaptativo tiene mejores posibilidades de encontrar jugadas balanceadas.
 * 
 * @returns {Object|null} - Estadísticas detalladas o null si no hay datos suficientes
 */

/**
 * Función auxiliar para evaluar la calidad general de la distribución
 */
            /**
 * Extrae el primer movimiento de una línea de variante principal (PV) en formato UCI
 * 
 * Esta función es crucial para el sistema adaptativo porque permite convertir
 * la línea de análisis seleccionada en un movimiento ejecutable. Maneja la
 * conversión de notación algebraica estándar (SAN) a notación UCI y valida
 * que el movimiento sea legal en la posición actual.
 * 
 * @param {string} pvLine - Línea PV en formato SAN (ej: "1. Nf3 d5 2. g3 Nf6...")
 * @returns {string|null} - Movimiento en formato UCI (ej: "g1f3") o null si error
 */

/**
 * Intenta parsing manual de notación cuando el método automático falla
 * 
 * Esta función de respaldo maneja casos especiales de notación que podrían
 * no ser reconocidos automáticamente por la biblioteca chess.js.
 * 
 * @param {string} moveNotation - Movimiento en notación algebraica
 * @param {Chess} chessInstance - Instancia de Chess.js para validación
 * @returns {string|null} - Movimiento UCI o null si falla
 */

/**
 * Función de utilidad para validar un movimiento UCI contra la posición actual
 * 
 * Esta función puede ser útil para verificar movimientos antes de ejecutarlos,
 * proporcionando una capa adicional de seguridad en el sistema adaptativo.
 * 
 * @param {string} uciMove - Movimiento en formato UCI (ej: "e2e4")
 * @returns {boolean} - true si el movimiento es válido en la posición actual
 */

/**
 * Función de diagnóstico para analizar el contenido de una línea PV
 * 
 * Útil para debugging cuando las líneas PV no se procesan correctamente.
 * Proporciona información detallada sobre cómo se está interpretando la línea.
 * 
 * @param {string} pvLine - Línea PV para analizar
 * @returns {Object} - Información de diagnóstico
 */
function diagnosePVLine(pvLine) {
    if (!pvLine) {
        return { error: 'Línea PV vacía' };
    }
    
    const tokens = pvLine.trim().split(/\s+/);
    const moveTokens = tokens.filter(token => 
        token.match(/^[a-h1-8KQRBNOX+#=\-]+$/) && !token.match(/^\d+\.+$/)
    );
    
    return {
        originalLine: pvLine,
        totalTokens: tokens.length,
        moveTokens: moveTokens,
        firstMoveCandidate: moveTokens[0] || 'N/A',
        tokenBreakdown: tokens.map((token, index) => ({
            index,
            token,
            isMove: moveTokens.includes(token),
            isMoveNumber: token.match(/^\d+\.+$/) !== null
        }))
    };
}
    
    // ===================== PROCESAMIENTO DE LÍNEAS PRINCIPALES (PV) =====================
    
    // Extraer y procesar las variantes principales (secuencias de movimientos)
    const pvIndex = parts.indexOf('pv');
    if (pvIndex !== -1 && parts.length > pvIndex + 1) {
        const pvMoves = parts.slice(pvIndex + 1);
        const multipvIndex = parts.indexOf('multipv');
        const pvNumber = multipvIndex !== -1 ? parseInt(parts[multipvIndex + 1]) : 1;

        // Convertir movimientos UCI a notación algebraica estándar (SAN)
        const pvText = convertPVToSAN(pvMoves);
        
        // Inicializar estructura de PVs si no existe
        if (!lastStats.pvs) {
            lastStats.pvs = {};
        }
        
        // Almacenar la línea convertida
        lastStats.pvs[pvNumber] = pvText;

        // La primera variante se considera la línea principal por defecto
        if (pvNumber === 1) {
            lastStats.pv = pvText;
        }
        
        // Logging específico para el sistema adaptativo
        if (currentPVAnalysis.adaptationActive && lastStats.pvEvaluations && lastStats.pvEvaluations[pvNumber]) {
            const eval = lastStats.pvEvaluations[pvNumber].value;
            const distance = Math.abs(eval);
            
            // Reportar variantes que estén cerca del equilibrio
            if (distance <= 50) {
                addLog('adaptation', `PV${pvNumber} equilibrada: ${(eval/100).toFixed(2)} - ${pvText.substring(0, 20)}...`);
            }
        }
    }
    
    // ===================== PROCESAMIENTO ESPECÍFICO PARA MODO ADAPTATIVO =====================
    
    // Si el modo adaptativo está activo, realizar análisis adicional
    if (currentPVAnalysis.adaptationActive && lastStats.pvEvaluations) {
        // Contar cuántas variantes hemos recibido hasta ahora
        const receivedPVs = Object.keys(lastStats.pvEvaluations).length;
        const expectedPVs = currentPVAnalysis.pvCount;
        
        // Si hemos recibido todas las variantes esperadas, evaluar el equilibrio
        if (receivedPVs >= expectedPVs && receivedPVs >= 5) {
            // Buscar la variante más cercana al equilibrio
            let bestBalanceDistance = Infinity;
            let bestBalancePV = null;
            let bestBalanceEval = null;
            
            Object.keys(lastStats.pvEvaluations).forEach(pvNum => {
                const evalData = lastStats.pvEvaluations[pvNum];
                const distance = Math.abs(evalData.value);
                
                if (distance < bestBalanceDistance) {
                    bestBalanceDistance = distance;
                    bestBalancePV = pvNum;
                    bestBalanceEval = evalData.value;
                }
            });
            
            // Si encontramos una variante equilibrada, reportarla
            if (bestBalancePV && Math.random() < 0.4) { // Reportar ocasionalmente para no saturar logs
                addLog('adaptation', `Mejor equilibrio: PV${bestBalancePV} con ${(bestBalanceEval/100).toFixed(2)} (Δ${bestBalanceDistance}cp de ${receivedPVs} variantes)`);
            }
        }
    }
    
    // ===================== ACTUALIZACIÓN DE INTERFAZ =====================
    
    // Actualizar la visualización de la interfaz con la nueva información
    updateEngineDisplay();
    
    // Si hay cambios significativos en la evaluación y el modo adaptativo está activo,
    // considerar si necesitamos ajustar los parámetros de búsqueda
    if (currentPVAnalysis.adaptationActive && lastStats.evaluation) {
        const currentDistance = Math.abs(lastStats.evaluation.value);
        
        // Si estamos muy lejos del equilibrio y es una profundidad baja, 
        // el sistema podría necesitar más análisis
        if (currentDistance > 100 && lastStats.depth < 3) {
            // Esto se manejará en evaluateAdaptationResult(), pero podemos preparar información
            if (Math.random() < 0.1) { // Logging ocasional
                addLog('info', `Desequilibrio detectado: ${(lastStats.evaluation.value/100).toFixed(2)} a prof. ${lastStats.depth}`);
            }
        }
    }
}

        function parseScore(parts, scoreIndex) {
            const scoreType = parts[scoreIndex + 1];
            const scoreValue = parseInt(parts[scoreIndex + 2]);
            
            if (scoreType === 'cp') {
                const adjustedEval = chess.turn() === 'w' ? scoreValue : -scoreValue;
                lastStats.evaluation = {
                    value: adjustedEval,
                    type: 'cp'
                };
            } else if (scoreType === 'mate') {
                const adjustedMate = chess.turn() === 'w' ? scoreValue : -scoreValue;
                lastStats.evaluation = {
                    value: adjustedMate,
                    type: 'mate'
                };
            }
        }

        function convertPVToSAN(pvMoves) {
            try {
                const tempChess = new Chess(chess.fen());
                const sanMoves = [];
                
                for (const uciMove of pvMoves) {
                    if (uciMove.length >= 4) {
                        const from = uciMove.substring(0, 2);
                        const to = uciMove.substring(2, 4);
                        const promotion = uciMove.length > 4 ? uciMove[4] : undefined;
                        
                        const move = tempChess.move({
                            from: from,
                            to: to,
                            promotion: promotion
                        });
                        
                        if (move) {
                            sanMoves.push(move.san);
                        } else {
                            break;
                        }
                    }
                }
                
                if (sanMoves.length > 0) {
                    let pvText = '';
                    let fullMoveNumber = parseInt(chess.fen().split(' ')[5]);
                    let isWhiteTurn = chess.turn() === 'w';
                    
                    for (let i = 0; i < sanMoves.length; i++) {
                        if (i === 0 && !isWhiteTurn) {
                            pvText += `${fullMoveNumber}... ${sanMoves[i]} `;
                        } else if (i === 0 && isWhiteTurn) {
                            pvText += `${fullMoveNumber}. ${sanMoves[i]} `;
                        } else if ((i + (isWhiteTurn ? 1 : 0)) % 2 === 0) {
                            if (!isWhiteTurn || i > 0) {
                                fullMoveNumber++;
                            }
                            pvText += `${fullMoveNumber}. ${sanMoves[i]} `;
                        } else {
                            pvText += `${sanMoves[i]} `;
                        }
                    }
                    
                    return pvText.trim();
                }
            } catch (error) {
                console.warn('Error convirtiendo PV a SAN:', error);
            }
            
            return pvMoves.join(' ');
        }

        function updateEngineDisplay() {
            const evalEl = document.getElementById('evaluation');
            if (lastStats.evaluation && evalEl) {
                const evalData = lastStats.evaluation;
                const isMate = evalData.type === 'mate';
                const score = evalData.value;
                
                evalEl.textContent = formatEvaluation(score, isMate);
                evalEl.className = 'evaluation';
                
                if (isMate) {
                    evalEl.classList.add(score > 0 ? 'eval-positive' : 'eval-negative');
                } else {
                    if (score > 50) {
                        evalEl.classList.add('eval-positive');
                    } else if (score < -50) {
                        evalEl.classList.add('eval-negative');
                    } else {
                        evalEl.classList.add('eval-neutral');
                    }
                }
            }

            const pvLineEl = document.getElementById('pvLine');
            if (pvLineEl) {
                if (lastStats.pvs && Object.keys(lastStats.pvs).length > 0) {
                    const lines = Object.keys(lastStats.pvs)
                        .sort((a, b) => parseInt(a) - parseInt(b))
                        .map(num => `[${num}] ${lastStats.pvs[num]}`);
                    pvLineEl.textContent = lines.join('\n');
                } else if (lastStats.pv) {
                    pvLineEl.textContent = lastStats.pv;
                }
            }

            const engineStatsEl = document.getElementById('engineStats');
            if (engineStatsEl) {
                const depthText = `Prof: ${lastStats.depth}`;
                const npsText = lastStats.nps > 0 ? ` | ${(lastStats.nps / 1000).toFixed(0)}k n/s` : '';
                engineStatsEl.textContent = depthText + npsText;
                
                if (lastStats.nps > 0 && Math.random() < 0.1) {
                    addLog('info', `Prof: ${lastStats.depth} | ${(lastStats.nps / 1000).toFixed(0)}k n/s | Score: ${lastStats.evaluation ? (lastStats.evaluation.value/100).toFixed(2) : '--'}`);
                }
            }
        }

        // ===================== SISTEMA DE DESTACADO VISUAL =====================
        function highlightBestLine() {
            resetHighlights();
            
            const bestLineElement = document.getElementById('pvLine');
            const bestLine = bestLineElement.textContent.split('\n')[0].trim();

            if (bestLine === "Inicia el análisis para ver la mejor línea" || 
                bestLine === "Analizando..." || 
                !bestLine || 
                bestLine.length < 3) {
                return;
            }

            try {
                const moves = bestLine.split(/\s+/).filter(move => 
                    move.match(/^[a-h1-8KQRBNOX+#=\-]+$/) && 
                    !move.match(/^\d+\.+$/)
                );

                if (moves.length === 0) return;

                const tempChess = new Chess(chess.fen());
                const squares = [];
                const movesToProcess = moves.slice(0, 3);

                movesToProcess.forEach(move => {
                    try {
                        const moveObj = tempChess.move(move, { sloppy: true });
                        if (moveObj) {
                            squares.push(moveObj.from);
                            squares.push(moveObj.to);
                        }
                    } catch (e) {
                        console.warn(`Movimiento inválido en línea principal: ${move}`);
                    }
                });

                squares.forEach(square => {
                    const squareElements = document.querySelectorAll(`[data-square="${square}"]`);
                    squareElements.forEach(squareElement => {
                        if (squareElement && squareElement.tagName === 'rect') {
                            const file = square.charCodeAt(0) - 97;
                            const rank = parseInt(square[1]) - 1;
                            const isDark = (file + rank) % 2 === 1;
                            
                            squareElement.classList.add('square-highlight');
                            if (isDark) {
                                squareElement.classList.add('dark');
                            }
                            previousHighlightedSquares.push(squareElement);
                        }
                    });
                });
            } catch (error) {
                console.warn('Error al destacar la mejor línea:', error);
            }
        }

        function resetHighlights() {
            previousHighlightedSquares.forEach(square => {
                square.classList.remove('square-highlight', 'dark');
            });
            previousHighlightedSquares = [];
        }

        function setupPVObserver() {
            if (pvObserver) {
                pvObserver.disconnect();
            }
            
            const pvLineElement = document.getElementById('pvLine');
            if (pvLineElement) {
                pvObserver = new MutationObserver(() => {
                    setTimeout(highlightBestLine, 100);
                });
                
                pvObserver.observe(pvLineElement, {
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
        }

        // ===================== GESTIÓN DE MOVIMIENTOS LEGALES =====================
        function showLegalMoves() {
            if (!chess || chess.game_over()) return;

            const moves = chess.moves({ verbose: true });
            const movesList = document.getElementById('legalMovesList');
            const movesHeader = document.getElementById('legalMovesHeader');
            movesList.innerHTML = '';

            movesHeader.innerHTML = `<i class="fas fa-chess-knight"></i> Movimientos Legales (${moves.length})`;

            if (moves.length === 0) {
                movesList.innerHTML = '<div style="text-align: center; padding: 20px; color: #6c757d;">No hay movimientos legales</div>';
            } else {
                moves.forEach(move => {
                    const div = document.createElement('div');
                    div.className = 'move-item';
                    
                    div.innerHTML = `
                        <span class="move-notation">${move.san}</span>
                        <span class="move-coords">${move.from}-${move.to}</span>
                    `;
                    
                    div.addEventListener('click', () => {
                        makeMove(move.san);
                    });
                    movesList.appendChild(div);
                });
            }

            document.getElementById('legalMoves').style.display = 'block';
        }

        function hideLegalMoves() {
            document.getElementById('legalMoves').style.display = 'none';
        }

        // ===================== FUNCIONES UTILITARIAS =====================
        function updateMemoryStats() {
            const memoryStats = document.getElementById('memoryStats');
            if (window.performance && window.performance.memory) {
                const memory = window.performance.memory;
                memoryStats.textContent = `Mem: ${Math.round(memory.usedJSHeapSize / (1024 * 1024))}MB`;
            } else {
                memoryStats.textContent = 'Mem: N/A';
            }
        }

        // ===================== EVENTOS E INICIALIZACIÓN DEL SISTEMA =====================
        window.addEventListener('load', function() {
            if (!window.Chess) {
                alert('Error: No se pudo cargar la biblioteca de ajedrez.');
                return;
            }
            chess = new Chess();
            drawBoard();
            updateMemoryStats();
            updateButtonStates();
            setupPVObserver();
            
            const modeSelect = document.getElementById('modeSelect');
            if (modeSelect) {
                modeSelect.addEventListener('change', function(e) {
                    setGameMode(e.target.value);
                });
            }
            
            const adaptiveToggle = document.getElementById('adaptiveToggle');
            if (adaptiveToggle) {
                adaptiveToggle.addEventListener('change', function(e) {
                    const status = e.target.checked ? 'activado' : 'desactivado';
                    addLog('info', `Modo adaptativo ${status}`);
                    setTimeout(reportAdaptiveModeStatus, 100);
                });
            }
            
            addLog('success', 'Sistema de ajedrez inicializado correctamente');
        });
        
        window.addEventListener('beforeunload', function() {
            if (stockfish) {
                stockfish.terminate();
            }
            if (blobURL) {
                URL.revokeObjectURL(blobURL);
            }
            if (pvObserver) {
                pvObserver.disconnect();
            }
        });

        window.drawBoard = drawBoard;
        window.showLegalMoves = showLegalMoves;
        window.hideLegalMoves = hideLegalMoves;
        window.toggleEngine = toggleEngine;
        window.toggleAnalysis = toggleAnalysis;
        window.forceBestMove = forceBestMove;
        window.handleSquareClick = handleSquareClick;
        window.clearLogs = clearLogs;
        window.toggleLogsPause = toggleLogsPause;
    </script>
</body>
</html>
